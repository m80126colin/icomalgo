\documentclass[utf8]{beamer}

%% === CJK 套件 ===
\usepackage{CJKutf8,CJKnumb}                 % 中文套件
%% === AMS 標準套件 ===
\usepackage{amsmath,amsfonts,amssymb,amsthm} % 數學符號
\usepackage{ulem}
%% ===  ===
%\usepackage[chapter]{algorithm}              % 演算法套件
%\usepackage[noend]{algpseudocode}            % pseudocode 套件
\usepackage{listings}                        % 程式碼
%% === TikZ 套件 ===
\usepackage{tikz,tkz-graph,tkz-berge}        % 繪圖
\usepackage{multicol}
\usepackage{xkeyval,xargs}
\usepackage{xcolor}

\usetheme{Boadilla}
\usecolortheme{whale}

\setbeamertemplate{items}[circle]

%% === 設定 C++ 格式 ===
\lstset{%
  language=C++,                     % 設定語言
  %% === 空白, tab 相關 ===
  tabsize=2,                            % 設定 tab = 多少空白
  %showspaces=true,                      % 設定是否標示空白
  %showtabs=true,                        % 設定是否標示 tab
  %tab=\rightarrowfill,                  % 設定 tab 樣式
  %% === 行數相關 ===
  %numbers=left,                         % 行數標示位置
  %stepnumber=1,                         % 每隔幾行標示行數
  %numberstyle=\tiny,
  %% === 顏色設定 ===
  basicstyle=\ttfamily,
  keywordstyle=\color{blue}\ttfamily,
  stringstyle=\color{red!50!brown}\ttfamily,
  commentstyle=\color{green!50!black}\ttfamily,
  %identifierstyle=\color{black}\ttfamily,
  emphstyle=\color{purple}\ttfamily,
  extendedchars=false,
  texcl=true,
  moredelim=[l][\color{magenta}]{\#}
}

\begin{document}
\begin{CJK}{UTF8}{bkai}

\title{基礎程式設計技巧(一)\\程式與計算}
\author{許胖}
\institute[PCSH]{板燒高中}

\begin{frame}
  \titlepage
\end{frame}
\begin{frame}
  \frametitle{大綱}
  \begin{multicols}{2}
    \tableofcontents
  \end{multicols}
\end{frame}

\section{簡介}
\begin{frame}
  \frametitle{大綱}
  \begin{multicols}{2}
    \tableofcontents[currentsection]
  \end{multicols}
\end{frame}

\begin{frame}
  \frametitle{寫程式的差別}
  \begin{block}{寫出一個完整的程式 ...}<2->
    \begin{itemize}[<3->]
    \item 只要照著講義、照著書打一打，就可以動了。
    \end{itemize}
  \end{block}
  \begin{exampleblock}{寫「好」一個程式 ...}<4->
    \begin{enumerate}
    \item<5-> 要了解資料怎麼儲存在電腦中
    \item<6-> 程式怎麼開始執行，為什麼會執行
    \item<7-> 什麼時候會岀什麼狀況，然後判斷出來、修正 (也就是 debug)
    \item<8-> 用適當的工具解決問題
    \item<9-> ... 族繁不及\sout{被宰}備載
    \end{enumerate}
  \end{exampleblock}
  \begin{itemize}
  \item<10-> 以上就是\alert{培訓目標}！
  \item<11-> 就是要讓大家熟悉\alert{基本的 C++ 語法}，以及學會基本的 \alert{coding 技巧}。
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{關於許胖講義 ...}
  \begin{alertblock}{給參與「演算法競賽」的人 ...}<2->
    \begin{enumerate}
    \item<3-> 使用一個「有效」的方法解決問題
    \item<4-> 不僅如此，還要知道不同工具使用上的優缺點
    \item<5-> 手爆出很多 code，勇往直前
    \item<6-> 進到 TOI 二階，保送大學
    \end{enumerate}
  \end{alertblock}
  \begin{itemize}
    \item<7-> 寫程式不是只有演算法比賽，生命也不是只有一個出口
    \item<7-> 越往這個領域深入，就會看到更多無盡的事物
    \begin{itemize}
      \item<8-> 寫遊戲引擎
      \item<9-> 網頁設計
      \item<10-> 手機 App
      \item<11-> 韌體 coding
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{關於這份投影片}
  \begin{block}{目標}
    \begin{enumerate}[<+->]
    \item 知道 C++ 的語法皆為「\alert{運算}」
    \item 各運算子的用法及特性
    \item 注意\alert{未定義行為}
    \end{enumerate}
  \end{block}
  \begin{exampleblock}{XD}<+->
    \begin{itemize}
    \item 希望各位在之後的內容都要動手快樂寫程式 XD！
    \end{itemize}
  \end{exampleblock}
\end{frame}

\section{程式架構}
\begin{frame}
  \frametitle{大綱}
  \begin{multicols}{2}
    \tableofcontents[currentsection]
  \end{multicols}
\end{frame}

\subsection{基本程式架構}

\begin{frame}[fragile]
  \frametitle{基本程式架構}
  \begin{block}{C++ 基本架構}
    \pause
    \begin{lstlisting}
  #include <iostream>
  using namespace std;
  int main() {
  }
    \end{lstlisting}
  \end{block}
  \begin{exampleblock}{註}<3->
    \begin{itemize}
    \item 怎麼理解？\uncover<4->{ 不需要理解，我們先\alert{記}起來。}
    \item<5-> 基本上程式的內容都寫在\alert{大括號}中。
    \item<6-> 裡面每個符號都要一樣 (分號也是)。
    \end{itemize}
  \end{exampleblock}
\end{frame}

\subsection{輸出}

\begin{frame}[fragile]
  \frametitle{程式的輸出}
  \begin{block}{輸出}
    \begin{enumerate}[<+->]
      \item 試著在剛剛的大括號中打上「\lstinline{cout << 1;}{}」，會發生什麼事？
      \item 還不清楚的話，可以在更下一行加上「\lstinline{system("PAUSE");}{}」，在觀察看看。
    \end{enumerate}
  \end{block}
  \begin{exampleblock}{註}<+->
    \begin{itemize}
    \item \lstinline{cout}{} 是「輸出」符號，你要輸出的東西用「\lstinline{<<}{}」串連。
    \item<+-> \lstinline{system("PAUSE");}{} 代表「暫停」的意思。
      \begin{itemize}[<+->]
      \item 因為沒加上這行，程式就會直接執行結束。
      \item 加上這行，程式會在這裡「等你」。
      \end{itemize}
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{注意事項}
  \begin{block}{輸出}
    \begin{enumerate}
    \item<1-> 如果改成「\lstinline{cout << 1}{}」(去掉分號) 會發生什麼結果？
    \item<3-> 試試看「\lstinline{cout << 1 << 2;}{}」，和你所想的有何不同？
    \item<5-> 那麼「\lstinline{cout << 1 << " " << 2;}{}」呢？
    \end{enumerate}
  \end{block}
  \begin{exampleblock}{註}<2->
    \begin{itemize}
    \item<2-> 「分號」對 C++ 而言代表「\alert{一個句子的結束}」，因此當一行\alert{指令結束就要加分號}。
    \item<4-> \lstinline{<<}{} 可以串很多東西一起輸出。
    \item<5-> \lstinline{" "}{} 是雙引號中間夾著一個「空白」，\alert{要注意}！
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{換行「符號」}
  \begin{block}{換行}
    \begin{enumerate}[<+->]
    \item 試試看「\lstinline{cout << 1 << 2 << endl;}{}」，和「\lstinline{cout << 1 << 2;}{}」有什麼不同呢？
    \item 如果看不出來，試試看「\lstinline{cout << 1 << endl << 2;}{}」。
    \end{enumerate}
  \end{block}
  \begin{exampleblock}{註}<+->
    \begin{itemize}
    \item 「\lstinline{endl}」代表\alert{換行}符號，輸出中很好用。
    \end{itemize}
  \end{exampleblock}
\end{frame}

\subsection{變數}

\begin{frame}[fragile]
  \frametitle{變數}
  \begin{block}{變數}
    \begin{itemize}[<+->]
    \item 和數學「變數」的概念不太一樣
    \item 程式的變數像是「\alert{容器}」，可以裝資料。
    \item C++ 裡，每個容器都要先講好\alert{用途}，這個步驟叫做「\alert{宣告}」。
    \end{itemize}
  \end{block}
  \begin{alertblock}{宣告變數}<+->
  \begin{lstlisting}
  int x;
  \end{lstlisting}
  \end{alertblock}
  \begin{exampleblock}{註}<+->
    \begin{itemize}
    \item 宣告就是幫變數取名字，此例將變數取名為「\lstinline{x}{}」。
    \item<+-> 「\lstinline{int}{}」代表的意義是「\alert{整數}」，規定變數 \lstinline{x}{} \alert{只能裝整數}。
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{變數的功用}
  \begin{block}{把數字裝到變數}<+->
  \begin{lstlisting}
  #include <iostream>
  using namespace std;
  int main() {
    int x;             // 宣告變數 x
    x = 5;             // 把整數 5 裝進 x 裡面
    cout << x << endl; // 印出變數 x 存的值
  }
  \end{lstlisting}
  \end{block}
  \begin{exampleblock}{註}<+->
    \begin{itemize}
    \item 「\lstinline{int}{}」宣告變數可以裝整數之外，還有很多不同的種類，以後會慢慢介紹。
    \item<+-> 「\lstinline{x = 5;}{}」這行\alert{不要}和數學中的「等於」搞混。
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}
  \frametitle{練習看看}
  \begin{block}{練習}
    若把上個投影片「\lstinline{x = 5;}{}」改成
    \begin{enumerate}[<+->]
    \item 「\lstinline{x = 5.0;}{}」會發生什麼事？
    \item 「\lstinline{x = 0.5;}{}」呢？
    \item 那改成「\lstinline{5 = x;}{}」呢？
    \end{enumerate}
  \end{block}
  \begin{exampleblock}{註}<+->
    \begin{itemize}
      \item 這些練習目的是要讓你了解\alert{問題出現時}的現象，了解出問題的原因才有辦法 debug
      \item<+-> 為什麼會出現這些現象我們繼續下去就知道了
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{宣告多個變數}
  \begin{columns}[T]
    \begin{column}[T]{5cm}
    \begin{block}{宣告兩個整數}
      \begin{itemize}[<+->]
      \item 可以寫成這樣：
        \begin{lstlisting}
  int a;
  int b;
        \end{lstlisting}
      \item 更可以簡化成這樣：
        \begin{lstlisting}
  int a, b;
        \end{lstlisting}
      \end{itemize}
    \end{block}
    \end{column}
    \begin{column}[T]{5cm}
    \begin{exampleblock}{宣告三個整數}<+->
      \begin{lstlisting}
  int a, b, c;
      \end{lstlisting}
    \end{exampleblock}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{如果容器不塞東西呢 ...}
  \begin{block}{變數不塞整數進去}<+->
    \begin{lstlisting}
  #include <iostream>
  using namespace std;
  int main() {
    int x;             // 宣告變數 x
    cout << x << endl; // 印出變數 x 存的值
  }
    \end{lstlisting}
  \end{block}
  \begin{exampleblock}{練習}<+->
    \begin{enumerate}
    \item 執行看看，發生什麼事？
    \item<+-> 再執行幾次，又會發生什麼事呢？
    \end{enumerate}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{初始化}
  \begin{alertblock}{初始化}
    \begin{itemize}[<+->]
    \item C++ 中，所有變數都要自己去\alert{初始化}。
      \begin{itemize}
      \item 例如：\lstinline{x = 5;}{}，把整數 5 丟給 \lstinline{x}{} 等等。
      \end{itemize}
    \item 沒有初始化過的變數，裡面裝的資料是\alert{不確定}的。
      \begin{itemize}[<+->]
      \item 或許你很幸運看到 \lstinline{x}{} 都是 0
      \item 但那只是\alert{恰巧}而已。
      \end{itemize}
    \end{itemize}
  \end{alertblock}
\end{frame}

\subsection{輸入}

\begin{frame}[fragile]
  \frametitle{程式的輸入}
  \begin{block}{輸入}
    執行以下程式
    \begin{lstlisting}
  #include <iostream>
  using namespace std;
  int main() {
    int x;
    cin >> x;
    cout << x << endl;
  }
    \end{lstlisting}
    會發生什麼事呢？
  \end{block}
  \begin{exampleblock}{練習}<2->
  如果沒發生什麼事，試著輸入「1」再按 enter 鍵，會發生什麼事呢？
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{程式的輸入}
  \begin{exampleblock}{輸入「符號」}<1->
    \begin{itemize}
    \item 「\lstinline{cin}{}」代表輸入符號，可以輸入後面變數的資料。
      \begin{itemize}
      \item<2-> 此例中，\lstinline{x}{} 是整數，因此可以\alert{輸入一個整數}。
      \item<3-> \lstinline{cin}{} 的 \alert{\lstinline{>>}{}} 不要和 \lstinline{cout}{} 的 \alert{\lstinline{<<}{}} 搞混。
      \end{itemize}
    \end{itemize}
  \end{exampleblock}
  \begin{block}{練習 (續)}<4->
    \begin{itemize}
    \item 如果輸入「5.0」再按 enter 鍵呢？
    \item<5-> 如果輸入「0.5」再按 enter 鍵呢？
    \item<6-> 如果輸入「XD」再按 enter 鍵呢？
    \end{itemize}
  \end{block}
  \begin{alertblock}{多變數輸入}<7->
    \begin{lstlisting}
  int x, y;
  cin >> x >> y;
    \end{lstlisting}
    \begin{itemize}[<8->]
    \item 不要在輸入中加入「\lstinline{endl}{}」。
    \end{itemize}
  \end{alertblock}
\end{frame}

\subsection{資料型態}

\begin{frame}[fragile]
  \frametitle{資料型態}
  \begin{block}{資料型態}
    \begin{itemize}
    \item<1-> 有裝整數的容器，那麼當然也可以宣告裝「小數點」的容器啦！
    \item<2-> 這些不同用途的容器我們稱為「\alert{資料型態}」。
    \end{itemize}
  \end{block}
  \pause\pause
  \begin{table}[h]
    \begin{tabular}{|c|c|c|}
    \hline
    關鍵字                   & 意義 & 備註\\
    \hline
    \lstinline{bool}{}      & 布林值 & 只有 \lstinline{true}{} 和 \lstinline{false}{}\\
    \hline
    \lstinline{int}{}       & 整數 &\\
    \hline
    \lstinline{long long}{} & 長整數 & 存比較大的整數，以後會介紹\\
    \hline
    \lstinline{double}{}    & \alert{浮點數} & 也就是小數點\\
    \hline
    \end{tabular}
    \caption{資料型態}
  \end{table}
  \begin{exampleblock}{註}<4->
  詳細內容之後再介紹，先來用看看這些東西。
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{布林值}
  \begin{exampleblock}{布林值}
    \begin{itemize}[<+->]
    \item 一種資料型態，只拿來裝兩種數值：「\lstinline{true}{}」和「\lstinline{false}{}」。
    \end{itemize}
  \end{exampleblock}
  \begin{block}{宣告}<+->
    \begin{lstlisting}
  bool b;
    \end{lstlisting}
  \end{block}
  \begin{alertblock}{注意}<+->
    \begin{itemize}
    \item 兩種不同的宣告不能用「逗號」隔開：
      \begin{lstlisting}
  int a, bool b;
      \end{lstlisting}
    \item<+-> 逗號有\alert{特殊意義}，不要想成一般的「逗號」。
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{賦值}
  \begin{block}{定義}
    \begin{itemize}[<+->]
    \item 將一個「數值」裝進一個變數中，稱為\alert{賦值}。
    \item 例如，之前把整數 5 裝進整數變數 \lstinline{x}{} 中：
      \begin{lstlisting}
  int x;
  x = 5;
      \end{lstlisting}
    \end{itemize}
  \end{block}
  \begin{exampleblock}{賦值簡化}<+->
    \begin{itemize}
    \item 變數宣告和賦值可以寫在一起：
      \begin{lstlisting}
  int x = 5; // 宣告一個整數變數 x 並且把 5 裝進去
      \end{lstlisting}
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{布林值}
  \begin{block}{練習}
    \begin{lstlisting}
 bool b;
 cout << b << endl;
    \end{lstlisting}
    對程式碼的 \lstinline{b}{} 做以下賦值，會發生什麼事？
    \begin{enumerate}
    \item<2-> \lstinline{b = true;}{}
    \item<3-> \lstinline{b = false;}{}
    \item<4-> \lstinline{b = 2;}{}
    \item<5-> \lstinline{b = 0;}{}
    \item<6-> \lstinline{b = -1;}{}
    \end{enumerate}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{布林值的重要觀念}
  \begin{alertblock}{觀念}
    \begin{itemize}[<+->]
    \item C++ 中，「\alert{非零整數}」會被當做「\lstinline{true}{}」，印出時也會印出一個非零整數 (\alert{通常是 1})。
    \item 「0」會被當做「\lstinline{false}{}」，印出時會印出「\alert{0}」。
    \end{itemize}
  \end{alertblock}
  \begin{exampleblock}{技巧}<+->
  這個特性在之後會\alert{非常}常用！大家要注意！
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{浮點數}
  \begin{itemize}[<+->]
    \item 先跳過 \lstinline{long long}{}，先知道 \lstinline{long long}{} 也是存整數就好。
    \item 謎之音：「那幹嘛現在說= =」
  \end{itemize}
  \begin{alertblock}{浮點數宣告}<+->
    \begin{lstlisting}
  double d;
    \end{lstlisting}
  \end{alertblock}
  \begin{exampleblock}{賦值}<+->
    \begin{itemize}
    \item 把 1.0 丟給 \lstinline{d}{} $\Rightarrow$ \lstinline{d = 1.0;}{}
    \item<+-> 把 0.5 丟給 \lstinline{d}{} $\Rightarrow$ \lstinline{d = 0.5;}{}
      \begin{itemize}[<+->]
      \item 0.5 也可寫為 \lstinline{d = .5;}{}
      \end{itemize}
    \item<+-> \lstinline{18.23e5}{} $\Rightarrow$ 代表 $18.23\times{10^5}$ (\alert{科學記號})
    \end{itemize}
  \end{exampleblock}
\end{frame}

\section{算術運算子}
\begin{frame}
  \frametitle{大綱}
  \begin{multicols}{2}
    \tableofcontents[currentsection]
  \end{multicols}
\end{frame}

\subsection{運算性質}

\begin{frame}[fragile]
  \frametitle{算術運算子}
  \begin{table}[h]
    \begin{tabular}{|c|c|c|c|}
    \hline
    算術運算子      & 意義 & 運算順序 & 結合性\\
    \hline
    \lstinline{+}{} & 加法 & 6       & 左$\rightarrow$右\\
    \hline
    \lstinline{-}{} & 減法 & 6       & 左$\rightarrow$右\\
    \hline
    \lstinline{*}{} & 乘法 & 5       & 左$\rightarrow$右\\
    \hline
    \lstinline{/}{} & 除法 & 5       & 左$\rightarrow$右\\
    \hline
    \lstinline{%}{} & 取餘數 & 5       & 左$\rightarrow$右\\
    \hline
    \end{tabular}
  \caption{算術運算子}
  \end{table}
  \begin{exampleblock}{註}<2->
    \begin{itemize}
    \item<2-> 不管\alert{運算順序}和\alert{結合性}，一般來說可以用五則運算來理解
    \item<3-> 只不過程式跟數學還是有差距 ...
      \begin{itemize}[<4->]
      \item 這個故事說來話長，我們先舉個簡單的例子吧！
      \end{itemize}
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}
  \frametitle{舉個例子}
  \begin{exampleblock}{$1+2+3=?$}
    \begin{itemize}
    \item<2-> 答案：6。
    \item<3-> 為什麼？ (謎之音：「什麼為什麼？」)
    \end{itemize}
  \end{exampleblock}
  \begin{block}{定義}<4->
  \alert{二元運算}有一個\alert{運算子}和兩個\alert{運算元}，例如：
    \begin{enumerate}
    \item<5-> $1+2$：「$+$」稱為「運算子」，「$1$」和「$2$」稱為運算元 (我們常稱為「被加數」和「加數」)。
    \item<6-> 我們可以知道「加減乘除餘」都是二元運算。
    \end{enumerate}
  \end{block}
  \begin{itemize}[<7->]
  \item Well, 我們回到原來的問題 ...
  \end{itemize}
\end{frame}

\subsection{結合性與運算順序}

\begin{frame}[fragile]
  \frametitle{回到原來的問題 ...}
  \begin{exampleblock}{$1+2+3=?$}
    \begin{itemize}
    \item \alert{出現大麻煩啦！}
      \begin{itemize}[<2->]
        \item 根據剛剛說的，加法只有兩個運算元，那麼「$1+2+3$」該怎麼辦呢？
      \end{itemize}
    \item<3-> 解法：決定運算的\alert{方向}。例如：
      \begin{enumerate}
        \item<4-> 先算 $1+2=3$，再算 $\alert{3}+3=6$
        \item<5-> 先算 $2+3=5$，再算 $1+\alert{5}=6$
      \end{enumerate}
    \item<6-> 謎之音：「那還不是一樣嘛？廢話= =」
    \end{itemize}
  \end{exampleblock}
  \begin{alertblock}{注意}<7->
  決定運算方向對「計算機」而言\alert{意義重大}！
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{再舉個例子 ...}
  \begin{exampleblock}{$1-2-3=?$}
    \begin{itemize}
    \item<2-> 我們直觀上會先算 $1-2=-1$，再算 $\alert{-1}-3=-4$。
    \item<3-> 因此 C++ 在設計上也會把加減乘除餘的\alert{結合性}「設定」成\alert{從左到右算}。
    \end{itemize}
  \end{exampleblock}
  \pause \pause \pause
  \begin{table}[h]
    \begin{tabular}{|c|c|c|c|}
    \hline
    算術運算子      & 意義 & 運算順序 & \alert{結合性}\\
    \hline
    \lstinline{+}{} & 加法 & 6       & \alert{左$\rightarrow$右}\\
    \hline
    \lstinline{-}{} & 減法 & 6       & \alert{左$\rightarrow$右}\\
    \hline
    \lstinline{*}{} & 乘法 & 5       & \alert{左$\rightarrow$右}\\
    \hline
    \lstinline{/}{} & 除法 & 5       & \alert{左$\rightarrow$右}\\
    \hline
    \lstinline{%}{} & 取餘數 & 5       & \alert{左$\rightarrow$右}\\
    \hline
    \end{tabular}
    \caption{算術運算子}
  \end{table}
\end{frame}

\begin{frame}[fragile]
  \frametitle{萬一是四則運算呢？}
  \begin{exampleblock}{$1+2*3-4=?$}
    \begin{itemize}
    \item<2-> 我們的運算規則：「\alert{先乘除餘，後加減}」。
    \item<3-> 因此 C++ 發展出一套規則：\alert{運算順序}
      \begin{itemize}
      \item<4-> 運算順序小的優先運算
      \item<5-> 若運算順序相同，則依照運算方向做計算。
      \end{itemize}
    \end{itemize}
  \end{exampleblock}
  \pause \pause \pause \pause \pause
  \begin{table}[h]
    \begin{tabular}{|c|c|c|c|}
    \hline
    算術運算子      & 意義 & \alert{運算順序} & 結合性\\
    \hline
    \lstinline{+}{} & 加法 & \alert{6}       & 左$\rightarrow$右\\
    \hline
    \lstinline{-}{} & 減法 & \alert{6}       & 左$\rightarrow$右\\
    \hline
    \lstinline{*}{} & 乘法 & \alert{5}       & 左$\rightarrow$右\\
    \hline
    \lstinline{/}{} & 除法 & \alert{5}       & 左$\rightarrow$右\\
    \hline
    \lstinline{%}{} & 取餘數 & \alert{5}     & 左$\rightarrow$右\\
    \hline
    \end{tabular}
    \caption{算術運算子}
  \end{table}
\end{frame}

\begin{frame}
  \frametitle{回到原來例子}
  \begin{exampleblock}{$1+2*3-4=?$}
    \begin{align*}
    \onslide<1->{  & 1+\alert{2*3}-4 &\text{我們可以看到 }*\text{ 的運算順序最高}\\}
    \onslide<2->{= & \alert{1+6}-4   &\text{加法和減法運算順序相同，依照結合性從左到右算}\\}
    \onslide<3->{= & \alert{7-4}     &\text{依照結合性從左到右算}\\
                 = & 3}
    \end{align*}
  \end{exampleblock}
  \begin{alertblock}{觀念}<4->
    \begin{itemize}
    \item C++ 的四則運算用\alert{優先順序}和\alert{結合性}來處理。
    \item<5-> 這件事情非常重要，稍後就會知道為什麼。
    \end{itemize}
  \end{alertblock}
\end{frame}

\subsection{整數除法與除零問題}

\begin{frame}[fragile]
  \frametitle{整數除法}
  \begin{block}{整數除法}
    \begin{enumerate}[<+->]
    \item \lstinline{cout << 8 / 5 << endl;}{} 的結果？\onslide<+->{\alert{Ans: 1}}
    \item \lstinline{cout << 8.0 / 5.0 << endl;}{} 的結果？\onslide<+->{\alert{Ans: 1.6}}
    \end{enumerate}
  \end{block}
  \begin{exampleblock}{註}<+->
    \begin{itemize}
    \item 在 \lstinline{8 / 5}{} 中，8 和 5 被視為 \lstinline{int}{}，因此 C++ 會做「\alert{整數除法}」。
    \item<+-> 而在 \lstinline{8.0 / 5.0}{} 中，8.0 和 5.0 被視為浮點數 \lstinline{double}{}，因此會做「\alert{浮點數除法}」。
    \end{itemize}
  \end{exampleblock}
  \begin{itemize}[<+->]
  \item 除法還有另外一個問題點 ...
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{除以零}
  \begin{block}{試試看}
    我們知道數學上是不能除以零的，那程式呢？
    \begin{enumerate}
    \item \lstinline{cout << 1 / 0 << endl;}{}
    \item<3-> \lstinline{cout << 0 / 0 << endl;}{}
    \item<4-> \lstinline{cout << 1.0 / 0.0 << endl;}{}
    \item<5-> \lstinline{cout << 0.0 / 0.0 << endl;}{}
    \end{enumerate}
  \end{block}
  \begin{exampleblock}{註}<2->
  如果無法編譯成功，那麼就宣告一個變數，把分母裝進去再試試看。
  \end{exampleblock}
  \begin{alertblock}{注意}<6->
  通常編譯可以過，但是在執行時會出些狀況，各位知道出了哪些狀況就好，不用了解太詳細。
  \end{alertblock}
\end{frame}

\subsection{應用：取餘數}

\begin{frame}[fragile]
  \frametitle{取餘數}
  \begin{block}{觀察現象}
    \begin{enumerate}[<+->]
    \item \lstinline{cout << 5 % 3 << endl;}{} 會輸出什麼？\onslide<+->{\alert{Ans:2}}
    \item \lstinline{cout << (-5) % 3 << endl;}{} 呢？\onslide<+->{\alert{Ans:-2}}
    \end{enumerate}
  \end{block}
  \begin{exampleblock}{註}<+->
    \begin{itemize}
    \item 事情不該是這樣發展的啊！！！
    \item<+-> 謎之音：「應該結果是要 1 才對。」
      \begin{itemize}[<+->]
      \item C++ 一個\alert{奇怪的特性} ...
      \end{itemize}
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{解決辦法？}
  \begin{block}{問題}<+->
  要怎麼做出取餘數的效果呢？
  \end{block}
  \begin{enumerate}[<+->]
  \item 假設 n 要 mod m ...
  \item 首先，我們取 \lstinline{n % m}{}
    \begin{itemize}[<+->]
    \item 如果 $n\geq{0}$\onslide<+->{，會得到介於 $0$ 到 $m-1$ 的數字}
    \item 如果 $n<0$\onslide<+->{，會得到介於 $-(m-1)$ 到 $0$ 的數字}
    \end{itemize}
  \item 接著加上 m
    \begin{itemize}[<+->]
    \item 如果 $n\geq{0}$\onslide<+->{，會得到介於 $m$ 到 $2m-1$ 的數字}
    \item 如果 $n<0$\onslide<+->{，會得到介於 $-(m-1)+m=1$ 到 $m$ 的數字}
    \item 全都修成正值了！\onslide<+->{\alert{但還差最後一步 ...}}
    \end{itemize}
  \item 最後，再 mod m 一次，把所有數字修正回 $0$ 到 $m-1$ 之間。
    \begin{itemize}[<+->]
    \item 大功告成啦~ \lstinline{(n % m + m) % m}{}
    \end{itemize}
  \end{enumerate}
\end{frame}

\begin{frame}
  \frametitle{練習題}
  \begin{exampleblock}{\href{http://unfortunate-dog.github.io/articles/100/p10071/}{UVa 10071 - Back to High School Physics}}<+->
  \label{uva:10071}
  這題只要能夠讀懂題意就不難寫。如果不知道怎樣讀取多筆測資請先參考迴圈部分 (EOF 版)。
  \end{exampleblock}
  \begin{exampleblock}{\href{http://unfortunate-dog.github.io/articles/103/p10300/}{UVa 10300 - Ecological Premium}}<+->
  \label{uva:10300}
  一樣能讀懂題意就不難寫。
  \end{exampleblock}
\end{frame}

\section{比較和邏輯運算子}
\begin{frame}
  \frametitle{大綱}
  \begin{multicols}{2}
    \tableofcontents[currentsection]
  \end{multicols}
\end{frame}

\subsection{簡化規則}

\begin{frame}[fragile]
  \frametitle{比較運算子}
  \begin{table}[h]
    \begin{tabular}{|c|c|c|c|}
    \hline
    比較運算子         & 意義   & 運算順序 & 結合性\\
    \hline
    \lstinline{==}{} & 等於   & 9       & 左$\rightarrow$右\\
    \hline
    \lstinline{!=}{} & 不等於 & 9       & 左$\rightarrow$右\\
    \hline
    \lstinline{>}{}  & 大於   & 8       & 左$\rightarrow$右\\
    \hline
    \lstinline{<}{}  & 小於   & 8       & 左$\rightarrow$右\\
    \hline
    \lstinline{>=}{} & 不小於 & 8       & 左$\rightarrow$右\\
    \hline
    \lstinline{<=}{} & 不大於 & 8       & 左$\rightarrow$右\\
    \hline
    \end{tabular}
    \caption{比較運算子}
  \end{table}
  \begin{alertblock}{注意}<2->
    \begin{itemize}
    \item C++ 的等於寫作「\lstinline{==}{}」，不要和賦值的「\lstinline{=}{}」搞混。
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{回傳值}
  \begin{block}{例子}<+->
    \begin{enumerate}
    \item \lstinline{cout << (3 < 5) << endl;}{}，會發生什麼事？
    \end{enumerate}
  \end{block}
  \begin{exampleblock}{註}<+->
    \begin{itemize}
    \item 比較運算子也是\alert{二元運算}，他會比較兩邊數字大小：
      \begin{itemize}[<+->]
      \item 如果正確，則為 \lstinline{true}{}
      \item 否則就是 \lstinline{false}{}
      \end{itemize}
    \item<+-> 這種概念我們稱為「\alert{回傳值}」
      \begin{itemize}[<+->]
      \item 比較運算子的回傳值是布林值 \lstinline{bool}{}
      \item \alert{\lstinline{3 < 5}{}} $\Rightarrow$ \lstinline{true}{}
      \item 因為我們要輸出 \lstinline{true}{}，根據 C++ 的規則，我們知道 \lstinline{true}{} 代表\alert{非零}，因此會印出一個非零的數字 (通常是 1)
      \end{itemize}
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{運算簡化}
  \begin{block}{例子}<+->
  判斷整數 \lstinline{n % m}{} 是否「不是 0」。
  \end{block}
  \begin{exampleblock}{判斷整除}<+->
    \lstinline{n % m != 0}{}
    \begin{itemize}[<+->]
    \item 如果 \lstinline{n % m}{} 的回傳值 $\neq{0}$ $\Rightarrow$ \lstinline{true}{}
    \item 如果是 0，則為 \lstinline{false}{}
    \end{itemize}
  \end{exampleblock}
  \begin{alertblock}{簡化寫法}<+->
    \lstinline{n % m}{}
    \begin{itemize}[<+->]
    \item 如果 \lstinline{n % m}{} 的回傳值 $\neq{0}$ ，可以被當做「\lstinline{true}{}」
    \item 如果是 0，那麼就可以當做「\lstinline{false}{}」
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}
  \frametitle{遙遠的記憶}
  \begin{alertblock}{布林值的重要觀念}<+->
    \begin{itemize}
    \item C++ 中，「\alert{非零整數}」會被當做「\lstinline{true}{}」，印出時也會印出一個非零整數 (\alert{通常是 1})。
    \item 「0」會被當做「\lstinline{false}{}」，印出時會印出「\alert{0}」。
    \end{itemize}
  \end{alertblock}
  \begin{exampleblock}{註}<+->
    \begin{itemize}
    \item 簡化的寫法大多時候可以取代原來一般寫法。
    \item<+-> 通常比較運算子要和 \lstinline{if}{}、\lstinline{else}{} 配合。
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{邏輯運算子}
  \begin{table}[h]
    \begin{tabular}{|c|c|c|c|}
    \hline
    邏輯運算子         & 意義 & 運算順序 & 結合性\\
    \hline
    \lstinline{&&}{} & 且   & 13      & 左$\rightarrow$右\\
    \hline
    \lstinline{||}{} & 或   & 14      & 左$\rightarrow$右\\
    \hline
    \lstinline{!}{}  & 非   & 3       & \alert{右$\rightarrow$左}\\
    \hline
    \end{tabular}
    \caption{邏輯運算子}
  \end{table}
  \begin{exampleblock}{作用}<2->
    \begin{itemize}
    \item 一般來說是連接比較運算子
    \item<3-> 例如：\lstinline{1 < x && x < 5}{}
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{舉個例子}
  \begin{block}{例子}<+->
  判斷 x 是否介於 a 和 b 之間能不能寫成 \lstinline{a <= x <= b;}{} 呢？\onslide<+->{\alert{Ans:不行}。}
  \end{block}
  \begin{exampleblock}{用回傳值的觀點}<+->
    \begin{itemize}
    \item 我們知道 \lstinline{<=}{} 運算子在列出很多個時，會\alert{由左到右算}
    \item<+-> \alert{\lstinline{a <= x}{}} 先算出 \lstinline{true}{} 或者是 \lstinline{false}{}
    \item<+-> 假設 \lstinline{a=-4}{}、\lstinline{b=-1}{}、\lstinline{x=-2}{} (我們知道結果是 \lstinline{true}{})
      \begin{itemize}[<+->]
      \item \lstinline{a <= x <= b}{} 先算 \lstinline{a <= x}{} 得到 \lstinline{true}{}
      \item \lstinline{true <= b}{}，因為 \lstinline{true}{} 通常是 1，但此時 \lstinline{b=-1}{}，整句就會回傳 \lstinline{false}{}
      \item 但事實上 \lstinline{x}{} 是在 \lstinline{a}{} 和 \lstinline{b}{} 裡面。
      \end{itemize}
    \item<+-> \lstinline{a <= x}{} 是 \lstinline{false}{} 也會有同樣的問題。
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{練習題 (1)}
  \begin{exampleblock}{\href{http://unfortunate-dog.github.io/articles/100/p10055/}{UVa 10055 - Hashmat the brave warrior}}<+->
  \label{uva:10055}
  取絕對值有兩種做法，一種是用 \lstinline{if}{} 判斷；另一種是呼叫函數 \lstinline{abs()}{} 就好了。\lstinline{abs()}{} 函數被定義在 \lstinline{<cstdlib>}{} 中，雖然沒有 \lstinline{include}{} 在 Visual C++ 依然能編譯過，但是上傳時因為編譯器的原因會導致\alert{編譯錯誤} (Compilation Error, CE)。
  \end{exampleblock}
  \begin{alertblock}{注意}
  另外要注意這一題的整數型態需用 \lstinline{long long}{}，用 \lstinline{int}{} 會造成「溢位現象」，這個原因會在後面說明。
  \end{alertblock}
\end{frame}

\begin{frame}
  \frametitle{練習題 (2)}
  \begin{exampleblock}{\href{http://unfortunate-dog.github.io/articles/111/p11172/}{UVa 11172 - Relational Operators}}<+->
  \label{uva:11172}
  能夠理解題意就不難解決此道問題。
  \end{exampleblock}
  \begin{exampleblock}{\href{http://unfortunate-dog.github.io/articles/119/p11942/}{UVa 11942 - Lumberjack Sequencing}}<+->
  \label{uva:11942}
  依序給你一些木頭的長度，問你這些木頭是不是由長到短，或是由短到長排列。
  \end{exampleblock}
\end{frame}

\subsection{短路運算}

\begin{frame}[fragile]
  \frametitle{短路運算}
  \begin{block}{性質}<+->
    \begin{itemize}
    \item \lstinline{A && B}{}
      \begin{itemize}[<+->]
      \item \lstinline{&&}{} 運算子：只要 A 或 B 其中一個回傳 \lstinline{false}{}，則整個運算式就會是 \lstinline{false}{}
      \item C++ 設計上當 A 已經是 \lstinline{false}{} (也就是確定整個運算式\alert{必為} \lstinline{false}{})，則 C++ 會\alert{跳過} B
      \end{itemize}
    \end{itemize}
  \end{block}
  \begin{exampleblock}{範例}<+->
    \begin{lstlisting}
  int i, j;
  i = j = 0;
  if ((i++ < 0) && (j++ > 0))
    cout << "XD" << endl; // 這行不會輸出
  cout << i << " " << j << endl;
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{短路運算}
  \begin{block}{性質}<+->
    \begin{itemize}
    \item \lstinline{A || B}{}
      \begin{itemize}[<+->]
      \item \lstinline{||}{} 運算子：只要 A 或 B 其中一個回傳 \lstinline{true}{}，則整個運算式就會是 \lstinline{true}{}
      \item C++ 設計上當 A 已經是 \lstinline{true}{} (也就是確定整個運算式\alert{必為} \lstinline{true}{})，則 C++ 會\alert{跳過} B
      \end{itemize}
    \end{itemize}
  \end{block}
  \begin{exampleblock}{範例}<+->
    \begin{lstlisting}
  int i, j;
  i = j = 0;
  if ((i++ >= 0) || (j++ < 0))
    cout << "XD" << endl; // 會輸出 XD
  cout << i << " " << j << endl;
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\section{位元運算子}
\begin{frame}
  \frametitle{大綱}
  \begin{multicols}{2}
    \tableofcontents[currentsection]
  \end{multicols}
\end{frame}

\subsection{int 和 long long 的儲存形式}

\begin{frame}[fragile]
  \frametitle{基本觀念}
  \begin{exampleblock}{觀念}
    \begin{itemize}[<+->]
    \item \alert{位元} (bit, b)：計算機儲存資料的基本單位，只儲存 \alert{0 和 1}
    \item \alert{位元組} (byte, B)：因為位元很多，所以我們把 8 個位元「打包起來」，變成一個位元組
      \begin{table}[h]
        \begin{tabular}{|c|}
        \hline
        01001010\\
        \hline
        \end{tabular}
        \caption{位元組}
      \end{table}
    \item 常見應用
      \begin{itemize}[<+->]
      \item KB、MB、GB、TB、PB：資料大小
      \item Kbps、Mbps、Gbps：資料傳輸速度
      \end{itemize}
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{int 表示法}
  \begin{block}{int ...}
    \begin{itemize}
    \item 有至少 2 個位元組
    \item<2-> 謎之音：「蝦米？」\onslide<3->{\alert{不是 4 個位元組嘛！！！}}
    \item<4-> 事實上當初定義時，\lstinline{int}{} 只有「至少」2 位元組。
    \item<5-> 現今大多是 4 位元組。
    \end{itemize}
  \end{block}
  \pause \pause \pause \pause \pause
  \begin{table}[h]
    \begin{tabular}{|c|c|}
      \hline
      型態                     & 長度\\
      \hline
      \lstinline{bool}{}      & 1 位元組\\
      \hline
      \lstinline{int}{}       & 2 或 \alert{4} 位元組\\
      \hline
      \lstinline{long long}{} & 4 或 \alert{8} 位元組\\
      \hline
      \lstinline{double}{}    & 8 位元組\\
      \hline
    \end{tabular}
    \caption{位元組長度}
  \end{table}
\end{frame}

\begin{frame}[fragile]
  \frametitle{int 表示法}
  \begin{alertblock}{int 表示法}
    \begin{itemize}[<+->]
    \item 一般來說，\lstinline{int}{} 由 4 個位元組組成
      \begin{table}[h]
      \begin{tabular}{|c|c|c|c|}
      \hline
      10100010 & 00110011 & 00100111 & 10101101\\
      \hline
      \end{tabular}
      \end{table}
    \item 可以視為一個長度是 32 的二進位數字，我們將位數依照高低編號
      \begin{table}[h]
      \begin{tabular}{|c|c|c|c|}
      \hline
      $x_{31}x_{30}\cdots{x_{24}}$ & $x_{23}x_{22}\cdots{x_{16}}$ & $x_{15}x_{14}\cdots{x_{8}}$ & $x_{7}x_{6}\cdots{x_{0}}$\\
      \hline
      \end{tabular}
      \end{table}
    \item $x_{31}$ 表示正負號
      \begin{itemize}[<+->]
      \item 0 代表 \lstinline{int}{} 是正數
      \item 1 代表 \lstinline{int}{} 是負數
      \end{itemize}
    \end{itemize}
  \end{alertblock}
  \begin{exampleblock}{註}<+->
  \lstinline{int}{} 的儲存方式很特別，要多花一些力氣說明。
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{int 存正數的情況}
  \begin{alertblock}{規則}<+->
  依照一般的二進位方式儲存。
  \end{alertblock}
  \begin{exampleblock}{例如}<+->
    \begin{itemize}
    \item \lstinline{int x = 1;}{}
      \begin{table}[h]
      \begin{tabular}{|c|c|c|c|}
        \hline
        \alert{0}0000000 & 00000000 & 00000000 & 0000000\alert{1}\\
        \hline
      \end{tabular}
      \end{table}
    \item<+-> \lstinline{int x = 255;}{}
      \begin{table}[h]
      \begin{tabular}{|c|c|c|c|}
        \hline
        \alert{0}0000000 & 00000000 & 00000000 & \alert{11111111}\\
        \hline
      \end{tabular}
      \end{table}
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{int 存負數的情況}
  \begin{exampleblock}{舉例}
    \begin{itemize}[<+->]
    \item \lstinline{int x = -1;}{}
      \begin{table}[h]
        \begin{tabular}{|c|c|c|c|}
        \hline
        \alert{1}1111111 & 11111111 & 11111111 & 11111111\\
        \hline
        \end{tabular}
      \end{table}
    \item 謎之音：「根本黑魔法！」
    \end{itemize}
  \end{exampleblock}
  \begin{block}{想法}<+->
    \begin{itemize}
    \item 我們知道 $(-1)+1=0$，那麼拿這種表示法加加看
      \begin{table}[h]
        \begin{tabular}{|c|r|c|c|c|}
        \hline
            &          11111111 & 11111111 & 11111111 & 11111111\\
        \hline
        $+$ &          00000000 & 00000000 & 00000000 & 00000001\\
        \hline
        \hline
            & \alert{1}00000000 & 00000000 & 00000000 & 00000000\\
        \hline
        \end{tabular}
      \end{table}
    \item<+-> 紅色的 \alert{1} 因為超過 32 位元，因此被捨棄，稱為\alert{溢位}
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{int 負數規則}
  \begin{exampleblock}{練習}
    \begin{itemize}[<+->]
    \item \lstinline{int x = -2;}{}
    \onslide<+->{
      \begin{table}[h]
        \begin{tabular}{|c|c|c|c|}
        \hline
        11111111 & 11111111 & 11111111 & 11111110\\
        \hline
        \end{tabular}
      \end{table}
    }
    \item \lstinline{int x = -256;}{}
    \onslide<+->{
      \begin{table}[h]
        \begin{tabular}{|c|c|c|c|c|}
        \hline
        11111111 & 11111111 & 11111111 & 00000000\\
        \hline
        \end{tabular}
      \end{table}
    }
    \end{itemize}
  \end{exampleblock}
  \begin{alertblock}{重點}<+->
    \begin{itemize}
    \item 這種表示法稱為\alert{二補數 (2's complement)}
    \item<+-> 要想像負數 $-x$ 的表示法，訣竅是 $(-x)+x$ 會因為溢位等於 0
    \item<+-> 記得 \lstinline{0}{} 是\alert{全 0}，\lstinline{-1}{} 是\alert{全 1}
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{位元運算子}
  \begin{table}[h]
    \begin{tabular}{|c|c|c|c|}
    \hline
    位元運算子         & 意義      & 運算順序 & 結合性\\
    \hline
    \lstinline{<<}{} & 左移運算子 & 7      & 左$\rightarrow$右\\
    \hline
    \lstinline{>>}{} & 右移運算子 & 7      & 左$\rightarrow$右\\
    \hline
    \lstinline{&}{}  & 位元 AND  & 10     & 左$\rightarrow$右\\
    \hline
    \lstinline{^}{}  & 位元 XOR  & 11     & 左$\rightarrow$右\\
    \hline
    \lstinline{|}{}  & 位元 OR   & 12     & 左$\rightarrow$右\\
    \hline
    \lstinline{~}{}  & 1's 補數  & 3      & \alert{右$\rightarrow$左}\\
    \hline
    \end{tabular}
    \caption{位元運算子}
  \end{table}
  \begin{alertblock}{注意}<2->
    \begin{itemize}
    \item 左移運算子和右移運算子不要和 \lstinline{cin}{} 與 \lstinline{cout}{} 的 \lstinline{<<}{}、\lstinline{>>}{} 混淆
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{左移和右移運算子}
  \begin{block}{左移和右移}<+->
  在位元操作上左移和右移 k 個位元。
  \end{block}
  \begin{exampleblock}{舉例}<+->
    \begin{itemize}
    \item \lstinline{2 << 2}{}\onslide<+->{ $\Rightarrow$ \lstinline{8}{}}
    \end{itemize}
    \onslide<+->{
      \begin{table}[h]
        \begin{tabular}{|c|c|c|c|}
        \hline
        00000000 & 00000000 & 00000000 & 000000\alert{10}\\
        \hline
        \end{tabular}
      \onslide<+->{
        \begin{center}
          $\Downarrow$
        \end{center}
        \begin{tabular}{|c|c|c|c|}
        \hline
        00000000 & 00000000 & 00000000 & 0000\alert{10}00\\
        \hline
        \end{tabular}
      }
    \end{table}
    }
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{左移和右移運算子 (2)}
  \begin{exampleblock}{再來個例子}<+->
    \begin{itemize}
    \item \lstinline{5 >> 1}{}\onslide<+->{ $\Rightarrow$ \lstinline{2}{}}
    \onslide<+->{
      \begin{table}[h]
        \begin{tabular}{|c|c|c|c|}
        \hline
        00000000 & 00000000 & 00000000 & 00000\alert{101}\\
        \hline
        \end{tabular}
      \onslide<+->{
        \begin{center}
          $\Downarrow$
        \end{center}
        \begin{tabular}{|c|c|c|c|}
        \hline
        00000000 & 00000000 & 00000000 & 000000\alert{10}\\
        \hline
        \end{tabular}
      }
      \end{table}
    }
    \end{itemize}
  \end{exampleblock}
  \begin{alertblock}{注意}<+->
    \begin{itemize}
    \item 不管是左移還是右移，移出去的位元會被捨棄。
    \item<+-> 之前提到 $x_{31}$ 決定正負號，在左移右移會影響到 $x_{31}$ 時會比較複雜，例如
      \begin{itemize}[<+->]
      \item \lstinline{2147483647 << 1}{}
      \item \lstinline{-5 >> 1}{}
      \item \lstinline{(2147483647 << 1) >> 1}{}
      \end{itemize}
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{左移和右移運算子 (3)}
  \begin{block}{觀察}
    \begin{itemize}[<+->]
    \item \lstinline{a << k}{} 會得到什麼數字呢？
    \item 那麼 \lstinline{a >> k}{} 呢？
    \end{itemize}
  \end{block}
  \begin{alertblock}{結論}<+->
    \begin{itemize}
    \item 一般來說 \lstinline{a << k}{} 會得到 $a\times{2^k}$，\lstinline{a >> k}{} 會得到 $a / 2^k$
    \item<+-> 有些情況比較複雜，大家看看就好，起碼對這些運算「有感覺」。
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{位元運算子 (2)}
  \begin{block}{位元運算子}
    對於兩個位元 \lstinline{x}{} 和 \lstinline{y}{}，遵守以下運算規則：
    \begin{multicols}{3}
    \pause
      \begin{table}[h]
        \begin{tabular}{|c||c|c|}
        \hline
        \lstinline{&}{} & \alert{1} & \alert{0}\\
        \hline
        \hline
        \alert{1}       & 1         & 0\\
        \hline
        \alert{0}       & 0         & 0\\
        \hline
        \end{tabular}
        \caption{and 運算子}
      \end{table}
    \pause
      \begin{table}[h]
        \begin{tabular}{|c||c|c|}
        \hline
        \lstinline{^}{} & \alert{1} & \alert{0}\\
        \hline
        \hline
        \alert{1}       & 0         & 1\\
        \hline
        \alert{0}       & 1         & 0\\
        \hline
        \end{tabular}
        \caption{xor 運算子}
      \end{table}
    \pause
      \begin{table}[h]
        \begin{tabular}{|c||c|c|}
        \hline
        \lstinline{|}{} & \alert{1} & \alert{0}\\
        \hline
        \hline
        \alert{1}       & 1         & 1\\
        \hline
        \alert{0}       & 1         & 0\\
        \hline
        \end{tabular}
        \caption{or 運算子}
      \end{table}
    \end{multicols}
  \end{block}
  \pause
  \begin{exampleblock}{觀察}
    \begin{itemize}
    \item and、or 運算子類似之前的邏輯運算子，不同在於這是\alert{位元}運算。\pause
    \item xor 很特別，可以記為不同數字為 1，相同為 0。
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{舉例}
  \begin{itemize}[<+->]
  \item \lstinline{5 & 3}{}\onslide<+->{ $\Rightarrow$ \lstinline{1}{}}
  \begin{block}{結果}<+->
    \begin{table}[h]
      \begin{tabular}{|c|r|c|c|c|}
      \hline
           & 00000000 & 00000000 & 00000000 & 00000\alert{101}\\
      \hline
      $\&$ & 00000000 & 00000000 & 00000000 & 00000\alert{011}\\
      \hline
      \hline
           & 00000000 & 00000000 & 00000000 & 00000\alert{001}\\
      \hline
      \end{tabular}
    \end{table}
  \end{block}
  \item \lstinline{5 | 3}{}\onslide<+->{ $\Rightarrow$ \lstinline{7}{}}
  \begin{block}{結果}<+->
    \begin{table}[h]
      \begin{tabular}{|c|r|c|c|c|}
      \hline
          & 00000000 & 00000000 & 00000000 & 00000\alert{101}\\
      \hline
      $|$ & 00000000 & 00000000 & 00000000 & 00000\alert{011}\\
      \hline
      \hline
          & 00000000 & 00000000 & 00000000 & 00000\alert{111}\\
      \hline
      \end{tabular}
    \end{table}
  \end{block}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{位元運算子 (3)}
  \begin{block}{補數運算子}<+->
    對於兩個位元 \lstinline{x}{} 和 \lstinline{y}{}，遵守以下運算規則：
    \begin{table}[h]
      \begin{tabular}{|c||c|c|}
      \hline
      \lstinline{~}{} & \alert{1} & \alert{0}\\
      \hline
                      & 0         & 1\\
      \hline
      \end{tabular}
      \caption{and 運算子}
    \end{table}
  \end{block}
  \begin{exampleblock}{說明}<+->
    \begin{itemize}
    \item 就是把 1 變為 0，把 0 變為 1 (相當於邏輯運算子的 \lstinline{!}{})
    \item<+-> 又稱為 1's 補數
    \item<+-> \lstinline{~0}{}\onslide<+->{ $\Rightarrow$ \lstinline{-1}{}}
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{一元運算子}
  \begin{block}{一元運算子}<1->
    \alert{一元運算子}就是只有一個運算元的運算子。
    \pause
    \begin{table}[h]
      \begin{tabular}{|c|c|c|c|}
      \hline
      運算子           & 意義 & 運算順序 & 結合性\\
      \hline
      \lstinline{+}{} & 正號 & 3      & \alert{右$\rightarrow$左}\\
      \hline
      \lstinline{-}{} & 負號 & 3      & \alert{右$\rightarrow$左}\\
      \hline
      \end{tabular}
    \end{table}
  \end{block}
  \begin{exampleblock}{舉例}<3->
  \lstinline{~~3}{} 會先算右邊的 \lstinline{~3}{}，得到 \lstinline{-4}{}，接著 \lstinline{-4}{} 再和左邊的負號運算子「運算」，回傳結果為 \lstinline{3}{}。
  \end{exampleblock}
\end{frame}

\subsection{常用技巧：連續的 1}

\begin{frame}[fragile]
  \frametitle{常用技巧：連續的 1}
  \begin{block}{問題}<+->
  要怎樣產生 2 進位下連續 k 個 1？
  \end{block}
  \begin{exampleblock}{舉例}<+->
    \begin{itemize}
    \item 3 個 1
      \begin{table}[h]
        \begin{tabular}{|c|c|c|c|}
        \hline
        00000000 & 00000000 & 00000000 & 00000\alert{111}\\
        \hline
        \end{tabular}
      \end{table}
    \item<+-> 5 個 1
      \begin{table}[h]
        \begin{tabular}{|c|c|c|c|}
        \hline
        00000000 & 00000000 & 00000000 & 000\alert{11111}\\
        \hline
        \end{tabular}
      \end{table}
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{常用技巧：連續的 1}
  \begin{block}{問題}<+->
  要怎樣產生 2 進位下連續 k 個 1？
  \end{block}
  \begin{exampleblock}{觀察}<+->
    \begin{itemize}
    \item 可以很容易發現，k 個 1 恰好是 $2^k-1$。
    \item<+-> \alert{前提是不牽扯到正負號 $x_{31}$}
    \end{itemize}
  \end{exampleblock}
  \begin{alertblock}{結論}<+->
    \begin{itemize}
    \item \lstinline{(1 << k) - 1}{}
    \item<+-> 注意減號和左移運算子的優先順序。
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{常用技巧：連續的 1 (加強版)}
  \begin{block}{問題 \alert{(加強版)}}<1->
  要怎樣產生 2 進位下 $x_a$ 到 $x_b$ 都是 1？ (假設 $a<b$)
  \end{block}
  \begin{exampleblock}{舉例}<2->
    \begin{itemize}
    \item $x_0$ 到 $x_2$ \onslide<3->{$\Rightarrow$ 恰好是 3 個 1 的情形}
      \begin{table}[h]
        \begin{tabular}{|c|c|c|c|}
        \hline
        00000000 & 00000000 & 00000000 & 00000\alert{111}\\
        \hline
        \end{tabular}
      \end{table}
    \item<4-> $x_3$ 到 $x_7$
      \begin{table}[h]
        \begin{tabular}{|c|c|c|c|}
        \hline
        00000000 & 00000000 & 00000000 & \alert{11111}000\\
        \hline
        \end{tabular}
      \end{table}
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{常用技巧：連續的 1 (加強版)}
  \begin{block}{問題 \alert{(加強版)}}<+->
  要怎樣產生 2 進位下 $x_a$ 到 $x_b$ 都是 1？ (假設 $a<b$)
  \end{block}
  \begin{alertblock}{結論}<+->
    \begin{itemize}
    \item 觀察之後，可以發現是 $2^{b+1}-2^a$
    \item<+-> 該怎麼實作就從之前取 k 個 1 的方法去擴展就可以得到。
    \item<+-> 記得熟悉位元運算，有時候就會有題目會用到。
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{位元技巧：取負數}
  \begin{alertblock}{問題}<+->
  給你一個正數 \lstinline{x}{}，問如何不用負號的情況下求出 \lstinline{-x}{} 呢？
  \end{alertblock}
  \begin{block}{提示}<+->
  比較 \lstinline{-x}{} 和 \lstinline{~x}{} 的不同。
  \end{block}
  \begin{exampleblock}{註}<+->
  這個例子只是展現位元運算有時候很神奇，這個方法很多時候並不常用。
  \end{exampleblock}
\end{frame}

\subsection{常用技巧：遮罩與指定位元}

\begin{frame}[fragile]
  \frametitle{更多性質}
  \begin{block}{位元運算的性質}<1->
  再看看位元運算的性質：
    \pause
    \begin{multicols}{2}
      \begin{table}[h]
        \begin{tabular}{|c||c|}
        \hline
        \lstinline{&}{} & \alert{x}\\
        \hline
        \hline
        \alert{1}       & x\\
        \hline
        \alert{0}       & 0\\
        \hline
        \end{tabular}
        \caption{and 運算子}
      \end{table}
    \pause
      \begin{table}[h]
        \begin{tabular}{|c||c|}
        \hline
        \lstinline{|}{} & \alert{x}\\
        \hline
        \hline
        \alert{1}       & 1\\
        \hline
        \alert{0}       & x\\
        \hline
        \end{tabular}
        \caption{or 運算子}
      \end{table}
    \end{multicols}
  \end{block}
  \begin{exampleblock}{觀察}<4->
    \lstinline{x}{} 是變數時 ... (可能是 0 或 1)
    \begin{itemize}
    \item<5-> \lstinline{x & 0}{} 永遠是 \lstinline{0}{}
    \item<6-> \lstinline{x | 1}{} 永遠是 \lstinline{1}{}\onslide<7->{ \alert{(這些性質很有用途！)}}
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{常用技巧：遮罩}
  \begin{block}{問題}<+->
  要知道 $x_0$ 是 1 還是 0，要怎麼做呢？
  \end{block}
  \begin{exampleblock}{做法}<+->
    \begin{table}[h]
      \begin{tabular}{|c|c|c|c|c|}
      \hline
          & $x_{31}x_{30}\cdots{x_{24}}$ & $x_{23}x_{22}\cdots{x_{16}}$ & $x_{15}x_{14}\cdots{x_{8}}$ & $x_{7}x_{6}\cdots{x_{0}}$\\
      \hline
      $\&$ & 00000000 & 00000000 & 00000000 & 0000000\alert{1}\\
      \hline
      \hline
          & 00000000 & 00000000 & 00000000 & 0000000\alert{$x_0$}\\
      \hline
      \end{tabular}
    \end{table}
    \onslide<+->{還記得剛剛位元運算的性質嗎？}
  \end{exampleblock}
  \begin{alertblock}{推廣版}<+->
    \begin{itemize}
    \item 要知道 $x_i$ 是 1 還是 0 要怎麼做？
    \item<+-> 如果我們要取出 $x_a$ 到 $x_b$ 的位元，要怎麼做呢？
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{常用技巧：指定位元}
  \begin{block}{問題}<+->
  要如何把一個整數 x 當中，$x_a$ 的位元「變成」1？
  \end{block}
  \begin{exampleblock}{觀察}<+->
    將 $x_0$ 改為 1
    \begin{table}[h]
      \begin{tabular}{|c|c|c|c|c|}
      \hline
          & $x_{31}x_{30}\cdots{x_{24}}$ & $x_{23}x_{22}\cdots{x_{16}}$ & $x_{15}x_{14}\cdots{x_{8}}$ & $x_{7}x_{6}\cdots{x_{0}}$\\
      \hline
      \lstinline{|}{} & 00000000 & 00000000 & 00000000 & 0000000\alert{1}\\
      \hline
      \hline
          & $x_{31}x_{30}\cdots{x_{24}}$ & $x_{23}x_{22}\cdots{x_{16}}$ & $x_{15}x_{14}\cdots{x_{8}}$ & $x_{7}x_{6}\cdots{x_{1}}$\alert{1}\\
      \hline
      \end{tabular}
    \end{table}
  \end{exampleblock}
  \begin{alertblock}{註}<+->
  利用剛剛提到的性質：\lstinline{1}{} 和任意位元 or 起來都是 \lstinline{1}{}。
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{常用技巧：指定位元}
  \begin{exampleblock}{觀察 (續)}<+->
    將 $x_2$ 改為 1
    \begin{table}[h]
      \begin{tabular}{|c|c|c|c|c|}
      \hline
          & $x_{31}x_{30}\cdots{x_{24}}$ & $x_{23}x_{22}\cdots{x_{16}}$ & $x_{15}x_{14}\cdots{x_{8}}$ & $x_{7}\cdots{x_{3}}x_{2}x_{1}x_{0}$\\
      \hline
      \lstinline{|}{} & 00000000 & 00000000 & 00000000 & 00000\alert{1}00\\
      \hline
      \hline
          & $x_{31}x_{30}\cdots{x_{24}}$ & $x_{23}x_{22}\cdots{x_{16}}$ & $x_{15}x_{14}\cdots{x_{8}}$ & $x_{7}\cdots{x_{3}}$\alert{1}$x_{1}x_{0}$\\
      \hline
      \end{tabular}
    \end{table}
  \end{exampleblock}
  \begin{alertblock}{結論}<+->
  可以套用之前連續 1 的技巧，就可以任意指定一些位元為 1。
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{常用技巧：指定位元}
  \begin{block}{另一個問題}<+->
  要如何把一個整數 x 當中，$x_a$ 的位元「變成」0？
  \end{block}
  \begin{exampleblock}{觀察}<+->
    將 $x_0$ 改為 0
    \begin{table}[h]
      \begin{tabular}{|c|c|c|c|c|}
      \hline
          & $x_{31}x_{30}\cdots{x_{24}}$ & $x_{23}x_{22}\cdots{x_{16}}$ & $x_{15}x_{14}\cdots{x_{8}}$ & $x_{7}x_{6}\cdots{x_{0}}$\\
      \hline
      \lstinline{&}{} & 11111111 & 11111111 & 11111111 & 1111111\alert{0}\\
      \hline
      \hline
          & $x_{31}x_{30}\cdots{x_{24}}$ & $x_{23}x_{22}\cdots{x_{16}}$ & $x_{15}x_{14}\cdots{x_{8}}$ & $x_{7}x_{6}\cdots{x_{1}}$\alert{0}\\
      \hline
      \end{tabular}
    \end{table}
  \end{exampleblock}
  \begin{alertblock}{結論}<+->
    \begin{itemize}
    \item 同樣也是利用位元運算的性質，和剛剛指定 \lstinline{1}{} 相似。
    \item<+-> 求出此常數可利用「補數」來求出。
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{位元技巧：取 $2^k$ 餘數}
  \begin{itemize}[<+->]
  \item 取 2 的餘數
    \begin{itemize}
    \item 因為餘數只有 0、1 兩種，恰好是看 $x_0$
    \item \lstinline{x % 2}{} $\Rightarrow$ \lstinline{x & 1}{}
    \end{itemize}
  \item 取 4 的餘數
    \begin{itemize}
    \item 餘數只有 0(\lstinline{00}{})、1(\lstinline{01}{})、2(\lstinline{10}{})、3(\lstinline{11}{}) 四種，恰好是看 $x_1x_0$
    \item \lstinline{x % 4}{} $\Rightarrow$ \lstinline{x & 3}{} \onslide<+->{$\Rightarrow$ \lstinline{x & ((1 << 2) - 1)}{}}
    \end{itemize}
  \item 取 $2^k$ 的餘數 \onslide<+->{$\Rightarrow$ \lstinline{x & ((1 << k) - 1)}{}}
  \end{itemize}
  \begin{columns}[T]
    \begin{column}[T]{5.5cm}
    \begin{exampleblock}{優點}<+->
      \begin{itemize}
      \item 和「\lstinline{%}{}」相比速度較快。
      \item<+-> 在負數下也沒有問題。
      \end{itemize}
    \end{exampleblock}
    \end{column}
    \begin{column}[T]{5.5cm}
    \begin{alertblock}{缺點}<+->
      \begin{itemize}
      \item 不易閱讀。
      \item<+-> 只能取特定餘數。
      \item<+-> 要注意\alert{運算順序}！
      \end{itemize}
    \end{alertblock}
    \end{column}
  \end{columns}
\end{frame}

\subsection{Parity}

\begin{frame}[fragile]
  \frametitle{Parity}
  \begin{block}{Parity 問題}<+->
  給妳一個正整數 $x$，問在 2 進位下有幾個 1？
  \end{block}
  \begin{exampleblock}{範例}<+->
    \begin{itemize}
    \item Parity(5) \onslide<+->{$\Rightarrow$ 2}
    \onslide<+->{
    \begin{table}[h]
      \begin{tabular}{|c|c|c|c|}
      \hline
       00000000 & 00000000 & 00000000 & 00000\alert{1}0\alert{1}\\
      \hline
      \end{tabular}
    \end{table}
    }
    \item<+-> Parity(255) \onslide<+->{$\Rightarrow$ 8}
    \onslide<+->{
    \begin{table}[h]
      \begin{tabular}{|c|c|c|c|}
      \hline
       00000000 & 00000000 & 00000000 & \alert{11111111}\\
      \hline
      \end{tabular}
    \end{table}
    }
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Parity}
  \begin{block}{普通寫法}<+->
  一個一個計算：
    \begin{lstlisting}
  for (; x; x /= 2) {
    if (x % 2 != 0)
      cnt++;
  }
    \end{lstlisting}
  \end{block}
  \begin{exampleblock}{位元運算寫法}<+->
    \begin{lstlisting}
  for ( ; x; x >>= 1) { // 右移代替除法
    if (x & 1) // 省略「!= 0」，同時把除法改成位元運算
      cnt++;
  }
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Parity}
  \begin{exampleblock}{究極 Parity}<+->
  檢查 Parity 是否為奇數：
    \begin{lstlisting}
  unsigned int v; // 32-bit word
  v ^= v >> 1;
  v ^= v >> 2;
  v = (v & 0x11111111U) * 0x11111111U;
  (v >> 28) & 1;
    \end{lstlisting}
  \end{exampleblock}
  \begin{alertblock}{註}<+->
  看看就好，不要刻意去記這些炫砲技能。
  \end{alertblock}
\end{frame}

\subsection{xor 性質}

\begin{frame}[fragile]
  \frametitle{xor 性質}
  \begin{block}{xor 性質}<+->
  給一個整數 \lstinline{x}{}，\lstinline{x ^ x}{} 恆為 0。
  \end{block}
  \begin{exampleblock}{解說}<+->
    \begin{table}
    \begin{tabular}{|c|c|c|c|c|}
    \hline
      & $x_{31}x_{30}\cdots{x_{24}}$ & $x_{23}x_{22}\cdots{x_{16}}$ & $x_{15}x_{14}\cdots{x_{8}}$ & $x_{7}x_{6}\cdots{x_{0}}$\\
    \hline
     \lstinline{^}{} & $x_{31}x_{30}\cdots{x_{24}}$ & $x_{23}x_{22}\cdots{x_{16}}$ & $x_{15}x_{14}\cdots{x_{8}}$ & $x_{7}x_{6}\cdots{x_{0}}$\\
    \hline
    \hline
      & 00000000 & 00000000 & 00000000 & 00000000\\
    \hline
    \end{tabular}
    \end{table}
  \end{exampleblock}
  \begin{alertblock}{註}<+->
  xor 運算的性質是「同為 0 或同為 1 xor 起來就是 0」。
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{位元技巧：交換兩數}
  \begin{block}{問題}<+->
  交換兩個 \lstinline{int}{} x 和 y 的值。
  \end{block}
  \begin{columns}[T]
    \begin{column}[T]{3.5cm}
    \begin{exampleblock}{swap 版}<+->
      \begin{lstlisting}
  swap(x, y);
      \end{lstlisting}
    \end{exampleblock}
    \end{column}
    \begin{column}[T]{3.5cm}
    \begin{exampleblock}{變數版}<+->
      \begin{lstlisting}
  int tmp = x;
  x = y;
  y = tmp;
      \end{lstlisting}
    \end{exampleblock}
    \end{column}
    \begin{column}[T]{3.5cm}
    \begin{alertblock}{位元運算版}<+->
      \begin{lstlisting}
  x ^= y;
  y ^= x;
  x ^= y;
      \end{lstlisting}
    \end{alertblock}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{位元技巧：交換兩數}
  \begin{columns}[T]
    \begin{column}[T]{3.5cm}
    \begin{alertblock}{位元運算版}<1->
      \begin{lstlisting}
  x ^= y;
  y ^= x;
  x ^= y;
      \end{lstlisting}
    \end{alertblock}
    \end{column}
    \begin{column}[T]{7.5cm}
    \onslide<2->{
    \begin{table}[h]
      \begin{tabular}{c|c|c}
                 & \alert{x}           & \alert{y}\\
      \hline
      \hline
      原來的值    & x     & y \onslide<3->\\
      \hline
      第一行後 & x xor y & y \onslide<4->\\
      \hline
      第二行後 & x xor y & \uncover<4>{\alert{y} xor }x\uncover<4>{ xor \alert{y}} \onslide<6->\\
      \hline
      第三行後 & \uncover<6>{\alert{x} xor }y\uncover<6>{ xor \alert{x}} & x \onslide<7>\\
      \end{tabular}
    \end{table}
    }
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}
  \frametitle{練習題}
  \begin{exampleblock}{\href{http://unfortunate-dog.github.io/articles/104/p10469/}{UVa 10469 - To Carry or not to Carry}}<+->
  \label{uva:10469}
  這題算是位元運算的基本應用。
  \end{exampleblock}
\end{frame}

\section{指定運算子}
\begin{frame}
  \frametitle{大綱}
  \begin{multicols}{2}
    \tableofcontents[currentsection]
  \end{multicols}
\end{frame}

\subsection{運算性質}

\begin{frame}[fragile]
  \frametitle{指定運算子}
  \begin{table}[h]
    \begin{tabular}{|c|c|c|c|}
    \hline
    運算子           & 意義 & 運算順序 & 結合性\\
    \hline
    \lstinline{=}{} & 賦值 & 16     & \alert{右$\rightarrow$左}\\
    \hline
    \end{tabular}
    \caption{指定運算子}
  \end{table}
\end{frame}

\begin{frame}[fragile]
  \frametitle{複合指定運算子}
  \begin{table}[h]
    \begin{tabular}{|c|c|c|c|}
    \hline
    運算子            & 意義    & 運算順序 & 結合性\\
    \hline
    \lstinline{+=}{} & 加法賦值 & 16     & \alert{右$\rightarrow$左}\\
    \hline
    \lstinline{-=}{} & 加法賦值 & 16     & \alert{右$\rightarrow$左}\\
    \hline
    \lstinline{*=}{} & 乘法賦值 & 16     & \alert{右$\rightarrow$左}\\
    \hline
    \lstinline{/=}{} & 除法賦值 & 16     & \alert{右$\rightarrow$左}\\
    \hline
    \lstinline{%=}{} & 取餘賦值 & 16     & \alert{右$\rightarrow$左}\\
    \hline
    \end{tabular}
  \end{table}
  \begin{exampleblock}{意義}<2->
    這些複合指定運算子代表的意義為：
    \begin{multicols}{2}
    \begin{itemize}
    \item \lstinline{x += a}{} $\Rightarrow$ \lstinline{x = x + a}{}
    \item \lstinline{x -= a}{} $\Rightarrow$ \lstinline{x = x - a}{}
    \item \lstinline{x *= a}{} $\Rightarrow$ \lstinline{x = x * a}{}
    \item \lstinline{x /= a}{} $\Rightarrow$ \lstinline{x = x / a}{}
    \item \lstinline{x %= a}{} $\Rightarrow$ \lstinline{x = x % a}{}
    \item 不難理解。
    \end{itemize}
    \end{multicols}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{複合指定運算子}
  \begin{table}[h]
    \begin{tabular}{|c|c|c|c|}
    \hline
    運算子             & 意義         & 運算順序 & 結合性\\
    \hline
    \lstinline{<<=}{} & 左移賦值      & 16     & \alert{右$\rightarrow$左}\\
    \hline
    \lstinline{>>=}{} & 右移賦值      & 16     & \alert{右$\rightarrow$左}\\
    \hline
    \lstinline{&=}{}  & 位元 AND 賦值 & 16     & \alert{右$\rightarrow$左}\\
    \hline
    \lstinline{^=}{}  & 位元 XOR 賦值 & 16     & \alert{右$\rightarrow$左}\\
    \hline
    \lstinline{|=}{}  & 位元 OR 賦值  & 16     & \alert{右$\rightarrow$左}\\
    \hline
    \end{tabular}
  \end{table}
  \begin{exampleblock}{意義}<2->
    這些複合指定運算子代表的意義為：
    \begin{multicols}{2}
    \begin{itemize}
    \item \lstinline{x <<= a}{} $\Rightarrow$ \lstinline{x = x << a}{}
    \item \lstinline{x >>= a}{} $\Rightarrow$ \lstinline{x = x >> a}{}
    \item \lstinline{x &= a}{}  $\Rightarrow$ \lstinline{x = x & a}{}
    \item \lstinline{x ^= a}{}  $\Rightarrow$ \lstinline{x = x ^ a}{}
    \item \lstinline{x |= a}{}  $\Rightarrow$ \lstinline{x = x | a}{}
    \item 以此類推。
    \end{itemize}
    \end{multicols}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{複合指定運算子}
  \begin{table}[h]
    \begin{tabular}{|c|c|c|c|}
    \hline
    運算子            & 意義         & 運算順序 & 結合性\\
    \hline
    \lstinline{++}{} & 字尾遞增      & 2     & 左$\rightarrow$右\\
    \hline
    \lstinline{--}{} & 字尾遞減      & 2     & 左$\rightarrow$右\\
    \hline
    \lstinline{++}{} & 字首遞增      & 3     & 左$\rightarrow$右\\
    \hline
    \lstinline{--}{} & 字首遞減      & 3     & 左$\rightarrow$右\\
    \hline
    \end{tabular}
  \end{table}
  \begin{exampleblock}{註}<2->
    \begin{itemize}
    \item 字尾系列寫做「\lstinline{i++}{}」、「\lstinline{j--}{}」。
    \item<3-> 字頭系列寫做「\lstinline{++i}{}」、「\lstinline{--j}{}」。
    \item<4-> 不管是字首還是字尾，代表的意義都是 \lstinline{i = i + 1}{} 和 \lstinline{j = j - 1}{}
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{字首系列 vs 字尾系列}
  \begin{block}{試試看}<+->
    \begin{itemize}
    \item \lstinline{cout << i++ << endl;}{}
    \item \lstinline{cout << ++i << endl;}{}
    \item \lstinline{i++; cout << i << endl;}{}
    \item \lstinline{++i; cout << i << endl;}{}
    \end{itemize}
    比較這四者之間有何不同？
  \end{block}
  \begin{columns}[T]
    \begin{column}[T]{5.5cm}
    \begin{exampleblock}{字首系列}<+->
      \begin{itemize}
      \item 會先做運算，再回傳
      \item<+-> 回傳值是運算\alert{後}的值
      \end{itemize}
    \end{exampleblock}
    \end{column}
    \begin{column}[T]{5.5cm}
    \begin{alertblock}{字尾系列}<+->
      \begin{itemize}
      \item 會先回傳，再做運算
      \item<+-> 回傳值是運算\alert{前}的值
      \end{itemize}
    \end{alertblock}
    \end{column}
  \end{columns}
\end{frame}

\subsection{未定義行為}

\begin{frame}[fragile]
  \frametitle{未定義行為}
  \begin{exampleblock}{例子}<+->
    \begin{lstlisting}
  int i = 0;
  cout << i++ + ++i << endl;
    \end{lstlisting}
    答案是多少？
  \end{exampleblock}
  \begin{block}{註}<+->
    \begin{itemize}
    \item 答案：\alert{沒有人知道！}
    \item<+-> 在不同的編譯器會有不同的結果。
    \item<+-> 大多數是因為在同一行之內改同一變數\alert{一次}以上。
    \end{itemize}
  \end{block}
  \begin{alertblock}{其他例子}<+->
    \begin{itemize}
    \item \lstinline{i = ++i + 1;}{}
    \item<+-> \lstinline{i++*++i+i--*--i}{}
    \end{itemize}
  \end{alertblock}
\end{frame}

\section{其他運算子}
\begin{frame}
  \frametitle{大綱}
  \begin{multicols}{2}
    \tableofcontents[currentsection]
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitle{其他運算子}
  \begin{table}[h]
    \begin{tabular}{|c|c|c|c|}
    \hline
    運算子                & 意義       & 運算順序 & 結合性\\
    \hline
    \lstinline{sizeof}{} & 求記憶體大小 & 3      & \alert{右$\rightarrow$左}\\
    \hline
    \lstinline{(type)}{} & 強制轉型    & 3      & \alert{右$\rightarrow$左}\\
    \hline
    \lstinline{,}{}      & 逗號       & 18      & 左$\rightarrow$右\\
    \hline
    \end{tabular}
  \end{table}
  \begin{alertblock}{觀念}<2->
    \begin{itemize}
    \item 萬物對計算機而言皆是「\alert{運算}」。
    \item<3-> 既然是運算，就有「結合性」和「運算順序」。
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{sizeof 運算子}
  \begin{block}{用途}<+->
  可以知道某個\alert{資料型態}或\alert{變數}所使用的位元組數。
  \end{block}
  \begin{exampleblock}{例子}<+->
    \begin{itemize}
    \item \lstinline{sizeof(int)}{}\onslide<+->{ 在\alert{筆者的機器}上會是 4 位元組}
    \item<+-> \lstinline{sizeof(double)}{}\onslide<+->{ 在\alert{筆者的機器}上會是 8 位元組}
    \item<+->
      \begin{lstlisting}
      bool b = true;
      cout << sizeof b << endl;
      \end{lstlisting}
      \onslide<+->{在\alert{筆者的機器}上會是 1 位元組}
    \end{itemize}
  \end{exampleblock}
  \begin{alertblock}{注意}<+->
  每個人的機器會出現不同的結果，像是之前提到有些機器的 \lstinline{int}{} 會是 2 個位元組。
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{型別轉換}
  \begin{block}{(type) 運算子}<+->
  C++ 有資料型態，若型態間需要\alert{強制轉換}就要使用這個運算子
  \end{block}
  \begin{exampleblock}{例子}<+->
    \begin{itemize}
    \item \lstinline{int}{} 變數 \lstinline{x}{} 轉為 \lstinline{double}{} %
      \onslide<+->{$\rightarrow$ \lstinline{(double) x}{} 或者 \lstinline{double(x)}{}}
    \item<+-> \lstinline{double}{} 常數轉為 \lstinline{int}{} %
      \onslide<+->{$\rightarrow$ \lstinline{(int) 5.14}{} 或者 \lstinline{int(5.14)}{}}
    \end{itemize}
  \end{exampleblock}
  \begin{alertblock}{註}<+->
  我們說過資料型態代表容器可以裝的資料類型不同，因此我們之後會遇到需要「\alert{改變資料類型}」的狀況，那時需要做型別轉換。
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{逗號運算子}
  \begin{block}{意義}
    \begin{itemize}
    \item 最常被人誤解的\alert{運算子}\onslide<2->{、\alert{運算子}}\onslide<3->{、\alert{運算子}！(因為很重要所以要說三次)}
    \item<4-> 逗號運算子可以\alert{分隔}兩個運算式，回傳值是\alert{右邊}運算式的回傳值。
    \end{itemize}
  \end{block}
  \begin{exampleblock}{實例}<5->
  用迴圈讀入 n，直到 $n=0$ 停止：
    \pause \pause \pause \pause \pause
    \begin{lstlisting}
  int n;
  while (cin >> n, n) {
  }
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\section{結論}
\begin{frame}
  \frametitle{大綱}
  \begin{multicols}{2}
    \tableofcontents[currentsection]
  \end{multicols}
\end{frame}

\begin{frame}[fragile]
  \frametitle{小結}
  \begin{alertblock}{重點整理}
    \begin{enumerate}[<+->]
    \item 句子結尾是分號「\lstinline{;}{}」。
    \item 初始化的重要性。
    \item C++ 運算子依照運算順序和結合性做運算，大約了解運算的優先順序。
    \item 除以零會遇到的現象。
    \item 「零」代表 \lstinline{false}{}，「非零」代表 \lstinline{true}{}。
    \item 邏輯運算子是短路運算。
    \item \lstinline{int}{} 和 \lstinline{long long}{} 如何儲存，以及位元運算技巧。
    \item 注意未定義行為。
    \end{enumerate}
  \end{alertblock}
\end{frame}

\begin{frame}
  \frametitle{運算子小結}
  \begin{exampleblock}{運算優先順序}<+->
  一元運算子 $\rightarrow$ 算術運算子 $\rightarrow$ 比較運算子 $\rightarrow$ 邏輯運算子 $\rightarrow$ 位元運算子 $\rightarrow$ 指定運算子、複合指定運算子 $\rightarrow$ 逗號運算子
  \end{exampleblock}
  \begin{alertblock}{觀念}<+->
    \begin{itemize}
    \item 萬一忘記順序怎麼辦呢？
    \item<+-> 當然是把\alert{括號括好}啦～運算順序只要知道大概，這不是必背的東西，我們的目的是「寫出好程式」而非在運算順序上多作著墨！
    \end{itemize}
  \end{alertblock}
\end{frame}

\clearpage
\end{CJK}
\end{document}