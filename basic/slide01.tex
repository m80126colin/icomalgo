\documentclass[utf8]{beamer}

%% === CJK 套件 ===
\usepackage{CJKutf8,CJKnumb}                 % 中文套件
%% === AMS 標準套件 ===
\usepackage{amsmath,amsfonts,amssymb,amsthm} % 數學符號
\usepackage{ulem}
%% ===  ===
%\usepackage[chapter]{algorithm}              % 演算法套件
%\usepackage[noend]{algpseudocode}            % pseudocode 套件
\usepackage{listings}                        % 程式碼
%% === TikZ 套件 ===
\usepackage{tikz,tkz-graph,tkz-berge}        % 繪圖
\usepackage{multicol}
\usepackage{xkeyval,xargs}
\usepackage{xcolor}

\usetheme{Boadilla}
\usecolortheme{whale}

\setbeamertemplate{items}[circle]

%% === 設定 C++ 格式 ===
\lstset{%
  language=C++,                     % 設定語言
  %% === 空白, tab 相關 ===
  tabsize=2,                            % 設定 tab = 多少空白
  %showspaces=true,                      % 設定是否標示空白
  %showtabs=true,                        % 設定是否標示 tab
  %tab=\rightarrowfill,                  % 設定 tab 樣式
  %% === 行數相關 ===
  %numbers=left,                         % 行數標示位置
  %stepnumber=1,                         % 每隔幾行標示行數
  %numberstyle=\tiny,
  %% === 顏色設定 ===
  basicstyle=\ttfamily,
  keywordstyle=\color{blue}\ttfamily,
  stringstyle=\color{red!50!brown}\ttfamily,
  commentstyle=\color{green!50!black}\ttfamily,
  identifierstyle=\color{black}\ttfamily,
  emphstyle=\color{purple}\ttfamily,
  extendedchars=false,
  texcl=true,
  moredelim=[l][\color{magenta}]{\#}
}

\begin{document}
\begin{CJK}{UTF8}{bkai}

\title{基礎程式設計技巧(一)\\程式與計算}
\author{許胖}
\institute[PCSH]{板燒高中}

\begin{frame}
  \titlepage
\end{frame}
\begin{frame}
  \frametitle{大綱}
  \begin{multicols}{2}
    \tableofcontents
  \end{multicols}
\end{frame}

\section{簡介}
\begin{frame}
  \frametitle{大綱}
  \begin{multicols}{2}
    \tableofcontents[currentsection]
  \end{multicols}
\end{frame}

\begin{frame}
  \frametitle{寫程式的差別}
  \begin{block}{寫出一個完整的程式 ...}<2->
    \begin{itemize}[<3->]
    \item 只要照著講義、照著書打一打，就可以動了。
    \end{itemize}
  \end{block}
  \begin{exampleblock}{寫「好」一個程式 ...}<4->
    \begin{enumerate}
    \item<5-> 要了解資料怎麼儲存在電腦中
    \item<6-> 程式怎麼開始執行，為什麼會執行
    \item<7-> 什麼時候會岀什麼狀況，然後判斷出來、修正 (也就是 debug)
    \item<8-> 用適當的工具解決問題
    \item<9-> ... 族繁不及\sout{被宰}備載
    \end{enumerate}
  \end{exampleblock}
  \begin{itemize}
  \item<10-> 以上就是快樂寒訓營的\alert{培訓目標}！
  \item<11-> 也就是要讓大家熟悉\alert{基本的 C++ 語法}，以及學會基本的 \alert{coding 技巧}。
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{關於許胖講義 ...}
  \begin{alertblock}{給參與「演算法競賽」的人 ...}<2->
    \begin{enumerate}
    \item<3-> 使用一個「有效」的方法解決問題
    \item<4-> 不僅如此，還要知道不同工具使用上的優缺點
    \item<5-> 手爆出很多 code，勇往直前
    \item<6-> 進到 TOI 二階，保送大學
    \end{enumerate}
  \end{alertblock}
  \begin{itemize}
    \item<7-> 寫程式不是只有演算法比賽，生命也不是只有一個出口
    \item<7-> 越往這個領域深入，就會看到更多無盡的事物
    \begin{itemize}
      \item<8-> 寫遊戲引擎
      \item<9-> 網頁設計
      \item<10-> 手機 App
      \item<11-> 韌體 coding
    \end{itemize}
  \end{itemize}
  \begin{exampleblock}{XD}<12->
  祝各位接下來一周快樂寫程式 XD！
  \end{exampleblock}
\end{frame}

\section{程式架構}
\begin{frame}
  \frametitle{大綱}
  \begin{multicols}{2}
    \tableofcontents[currentsection]
  \end{multicols}
\end{frame}

\subsection{基本程式架構}

\begin{frame}[fragile]
  \frametitle{基本程式架構}
  \begin{block}{C++ 基本架構}
    \pause
    \begin{lstlisting}
  #include <iostream>
  using namespace std;
  int main() {
  }
    \end{lstlisting}
  \end{block}
  \begin{exampleblock}{註}<3->
    \begin{itemize}
    \item 怎麼理解？
      \begin{itemize}[<4->]
      \item 不需要理解，我們先記起來。
      \end{itemize}
    \item<5-> 基本上程式的內容都寫在\alert{大括號}中。
    \item<6-> 裡面每個符號都要一樣 (分號也是)。
    \end{itemize}
  \end{exampleblock}
\end{frame}

\subsection{輸出}

\begin{frame}[fragile]
  \frametitle{程式的輸出}
  \begin{block}{輸出}
    \begin{enumerate}[<+->]
      \item 試著在剛剛的大括號中打上「\lstinline{cout << 1;}」，會發生什麼事？
      \item 還不清楚的話，可以在更下一行加上「\lstinline{system("PAUSE");}」，在觀察看看。
    \end{enumerate}
  \end{block}
  \begin{exampleblock}{註}<+->
    \begin{itemize}
    \item \lstinline{cout} 是「輸出」符號，你要輸出的東西用「\lstinline{<<}」串連。
    \item<+-> \lstinline{system("PAUSE");} 代表「暫停」的意思。
      \begin{itemize}[<+->]
      \item 因為沒加上這行，程式就會直接執行結束。
      \item 加上這行，程式會在這裡「等你」。
      \end{itemize}
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{注意事項}
  \begin{block}{輸出}
    \begin{enumerate}
    \item<1-> 如果改成「\lstinline{cout << 1}」(去掉分號) 會發生什麼結果？
    \item<3-> 試試看「\lstinline{cout << 1 << 2;}」，和你所想的有何不同？
    \item<5-> 那麼「\lstinline{cout << 1 << " " << 2;}」呢？
    \end{enumerate}
  \end{block}
  \begin{exampleblock}{註}<2->
    \begin{itemize}
    \item<2-> 「分號」對 C++ 而言代表「\alert{一個句子的結束}」，因此當一行\alert{指令結束就要加分號}。
    \item<4-> \lstinline{<<} 可以串很多東西一起輸出。
    \item<5-> \lstinline{" "} 是雙引號中間夾著一個「空白」，\alert{要注意}！
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{換行「符號」}
  \begin{block}{換行}
    \begin{enumerate}[<+->]
    \item 試試看「\lstinline{cout << 1 << 2 << endl;}」，和「\lstinline{cout << 1 << 2;}」有什麼不同呢？
    \item 如果看不出來，試試看「\lstinline{cout << 1 << endl << 2;}」。
    \end{enumerate}
  \end{block}
  \begin{exampleblock}{註}<+->
    \begin{itemize}
    \item 「\lstinline{endl}」代表\alert{換行}符號，輸出中很好用。
    \end{itemize}
  \end{exampleblock}
\end{frame}

\subsection{變數}

\begin{frame}[fragile]
  \frametitle{變數}
  \begin{block}{變數}
    \begin{itemize}[<+->]
    \item 和數學「變數」的概念不太一樣
    \item 程式的變數像是「\alert{容器}」，可以裝資料。
    \item C++ 裡，每個容器都要先講好\alert{用途}，這個步驟叫做「\alert{宣告}」。
    \end{itemize}
  \end{block}
  \begin{alertblock}{宣告變數}<+->
  \begin{lstlisting}
  int x;
  \end{lstlisting}
  \end{alertblock}
  \begin{exampleblock}{註}<+->
    \begin{itemize}
    \item 宣告就是幫變數取名字，此例將變數取名為「\lstinline{x}」。
    \item<+-> 「\lstinline{int}」代表的意義是「\alert{整數}」，規定變數 \lstinline{x} \alert{只能裝整數}。
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{變數的功用}
  \begin{block}{把數字裝到變數}<+->
  \begin{lstlisting}
  #include <iostream>
  using namespace std;
  int main() {
    int x;             // 宣告變數 x
    x = 5;             // 把整數 5 裝進 x 裡面
    cout << x << endl; // 印出變數 x 存的值
  }
  \end{lstlisting}
  \end{block}
  \begin{exampleblock}{註}<+->
    \begin{itemize}
    \item 「\lstinline{int}」宣告變數可以裝整數之外，還有很多不同的種類，以後會慢慢介紹。
    \item<+-> 「\lstinline{x = 5;}」這行\alert{不要}和數學中的「等於」搞混。
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}
  \frametitle{練習看看}
  \begin{block}{練習}
    若把上個投影片「\lstinline{x = 5;}」改成
    \begin{enumerate}[<+->]
    \item 「\lstinline{x = 5.0;}」會發生什麼事？
    \item 「\lstinline{x = 0.5;}」呢？
    \item 那改成「\lstinline{5 = x;}」呢？
    \end{enumerate}
  \end{block}
  \begin{exampleblock}{註}<+->
    \begin{itemize}
      \item 這些練習目的是要讓你了解\alert{問題出現時}的現象，了解出問題的原因才有辦法 debug
      \item<+-> 為什麼會出現這些現象我們繼續下去就知道了
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{宣告多個變數}
  \begin{exampleblock}{宣告兩個整數}
    \begin{itemize}[<+->]
    \item 可以寫成這樣：
      \begin{lstlisting}
  int a;
  int b;
      \end{lstlisting}
    \item 更可以簡化成這樣：
      \begin{lstlisting}
  int a, b;
      \end{lstlisting}
    \end{itemize}
  \end{exampleblock}
  \begin{exampleblock}{宣告三個整數}<+->
    \begin{lstlisting}
  int a, b, c;
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{如果容器不塞東西呢 ...}
  \begin{block}{變數不塞整數進去}<+->
    \begin{lstlisting}
  #include <iostream>
  using namespace std;
  int main() {
    int x;             // 宣告變數 x
    cout << x << endl; // 印出變數 x 存的值
  }
    \end{lstlisting}
  \end{block}
  \begin{exampleblock}{練習}<+->
    \begin{enumerate}
    \item 執行看看，發生什麼事？
    \item<+-> 再執行幾次，又會發生什麼事呢？
    \end{enumerate}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{初始化}
  \begin{alertblock}{初始化}
    \begin{itemize}[<+->]
    \item C++ 中，所有變數都要自己去\alert{初始化}。
      \begin{itemize}
      \item 例如：\lstinline{x = 5;}，把整數 5 丟給 \lstinline{x} 等等。
      \end{itemize}
    \item 沒有初始化過的變數，裡面裝的資料是\alert{不確定}的。
      \begin{itemize}[<+->]
      \item 或許你很幸運看到 \lstinline{x} 都是 0
      \item 但那只是\lstinline{恰巧}而已。
      \end{itemize}
    \end{itemize}
  \end{alertblock}
\end{frame}

\subsection{輸入}

\begin{frame}[fragile]
  \frametitle{程式的輸入}
  \begin{block}{輸入}
    執行以下程式
    \begin{lstlisting}
  #include <iostream>
  using namespace std;
  int main() {
    int x;
    cin >> x;
    cout << x << endl;
  }
    \end{lstlisting}
    會發生什麼事呢？
  \end{block}
  \begin{block}{練習}<2->
  如果沒發生什麼事，試著輸入「1」再按 enter 鍵，會發生什麼事呢？
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{程式的輸入}
  \begin{exampleblock}{輸入「符號」}<1->
    \begin{itemize}
    \item 「\lstinline{cin}」代表輸入符號，可以輸入後面變數的資料。
      \begin{itemize}
      \item<2-> 此例中，\lstinline{x} 是整數，因此可以\alert{輸入一個整數}。
      \item<3-> \lstinline{cin} 的 \alert{\lstinline{>>}} 不要和 \lstinline{cout} 的 \alert{\lstinline{<<}} 搞混。
      \end{itemize}
    \end{itemize}
  \end{exampleblock}
  \begin{block}{練習 (續)}<4->
    \begin{itemize}
    \item 如果輸入「5.0」再按 enter 鍵呢？
    \item<5-> 如果輸入「0.5」再按 enter 鍵呢？
    \item<6-> 如果輸入「XD」再按 enter 鍵呢？
    \end{itemize}
  \end{block}
  \begin{alertblock}{多變數輸入}<7->
    \begin{lstlisting}
  int x, y;
  cin >> x >> y;
    \end{lstlisting}
    \begin{itemize}[<8->]
    \item 不要在輸入中加入「\lstinline{endl}」。
    \end{itemize}
  \end{alertblock}
\end{frame}

\subsection{資料型態}

\begin{frame}[fragile]
  \frametitle{資料型態}
  \begin{block}{資料型態}
    \begin{itemize}
    \item<1-> 有裝整數的容器，那麼當然也可以宣告裝「小數點」的容器啦！
    \item<2-> 這些容器我們稱為「\alert{資料型態}」。
    \end{itemize}
  \end{block}
  \pause\pause
  \begin{table}[h]
    \begin{tabular}{|c|c|c|}
    \hline
    關鍵字                 & 意義 & 備註\\
    \hline
    \lstinline{bool}      & 布林值 & 只有 \lstinline{true} 和 \lstinline{false}\\
    \hline
    \lstinline{int}       & 整數 &\\
    \hline
    \lstinline{long long} & 長整數 & 存比較大的整數，以後會介紹\\
    \hline
    \lstinline{double}    & \alert{浮點數} & 也就是小數點\\
    \hline
    \end{tabular}
    \caption{資料型態}
  \end{table}
  \begin{exampleblock}{註}<4->
  詳細內容之後再介紹，先來用看看這些東西。
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{布林值}
  \begin{exampleblock}{布林值}
    \begin{itemize}[<+->]
    \item 一種資料型態，只拿來裝兩種數值：「\lstinline{true}」和「\lstinline{false}」。
    \end{itemize}
  \end{exampleblock}
  \begin{alertblock}{宣告}<+->
    \begin{lstlisting}
  bool b;
    \end{lstlisting}
  \end{alertblock}
  \begin{alertblock}{注意}<+->
    \begin{itemize}
    \item 兩種不同的宣告不能用「逗號」隔開：
      \begin{lstlisting}
  int a, bool b;
      \end{lstlisting}
    \item<+-> 逗號有\alert{特殊意義}，不要想成一般的「逗號」。
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{賦值}
  \begin{block}{定義}
    \begin{itemize}[<+->]
    \item 將一個「數值」裝進一個變數中，稱為\alert{賦值}。
    \item 例如，之前把整數 5 裝進整數變數 \lstinline{x} 中：
      \begin{lstlisting}
  int x;
  x = 5;
      \end{lstlisting}
    \end{itemize}
  \end{block}
  \begin{exampleblock}{賦值簡化}<+->
    \begin{itemize}
    \item 變數宣告和賦值可以寫在一起：
      \begin{lstlisting}
  int x = 5; // 宣告一個整數變數 x 並且把 5 裝進去
      \end{lstlisting}
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{布林值}
  \begin{block}{練習}
    \begin{lstlisting}
 bool b;
 cout << b << endl;
    \end{lstlisting}
    對程式碼的 \lstinline{b} 做以下賦值，會發生什麼事？
    \begin{enumerate}
    \item<2-> \lstinline{b = true;}
    \item<3-> \lstinline{b = false;}
    \item<4-> \lstinline{b = 2;}
    \item<5-> \lstinline{b = 0;}
    \item<6-> \lstinline{b = -1;}
    \end{enumerate}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{布林值的重要觀念}
  \begin{alertblock}{觀念}
    \begin{itemize}
    \item C++ 中，「\alert{非零整數}」會被當做「\lstinline{true}」，印出時也會印出一個非零整數 (\alert{通常是 1})。
    \item<2-> 「0」會被當做「\lstinline{false}」，印出時會印出「\alert{0}」。
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{浮點數}
  \begin{itemize}[<+->]
    \item 先跳過 \lstinline{long long}，先知道 \lstinline{long long} 也是存整數就好。
    \item 謎之音：「那幹嘛現在說= =」
  \end{itemize}
  \begin{alertblock}{浮點數宣告}<+->
    \begin{lstlisting}
  double d;
    \end{lstlisting}
  \end{alertblock}
  \begin{exampleblock}{賦值}<+->
    \begin{itemize}
    \item 把 1.0 丟給 \lstinline{d} $\Rightarrow$ \lstinline{d = 1.0;}
    \item<+-> 把 0.5 丟給 \lstinline{d} $\Rightarrow$ \lstinline{d = 0.5;}
      \begin{itemize}[<+->]
      \item 0.5 也可寫為 \lstinline{d = .5;}
      \end{itemize}
    \item<+-> \lstinline{18.23e5} $\Rightarrow$ 代表 $18.23\times{10^5}$ (\alert{科學記號})
    \end{itemize}
  \end{exampleblock}
\end{frame}

\section{算術運算子}
\begin{frame}
  \frametitle{大綱}
  \begin{multicols}{2}
    \tableofcontents[currentsection]
  \end{multicols}
\end{frame}

\subsection{運算性質}

\begin{frame}[fragile]
  \frametitle{算術運算子}
  \begin{table}[h]
    \begin{tabular}{|c|c|c|c|}
    \hline
    算術運算子      & 意義 & 運算順序 & 結合性\\
    \hline
    \lstinline{+} & 加法 & 6       & 左$\rightarrow$右\\
    \hline
    \lstinline{-} & 減法 & 6       & 左$\rightarrow$右\\
    \hline
    \lstinline{*} & 乘法 & 5       & 左$\rightarrow$右\\
    \hline
    \lstinline{/} & 除法 & 5       & 左$\rightarrow$右\\
    \hline
    \lstinline{%} & 取餘數 & 5       & 左$\rightarrow$右\\
    \hline
    \end{tabular}
  \caption{算術運算子}
  \end{table}
  \begin{exampleblock}{註}<2->
    \begin{itemize}
    \item<2-> 不管\alert{運算順序}和\alert{結合性}，一般來說可以用五則運算來理解
    \item<3-> 只不過程式跟數學還是有差距 ...
      \begin{itemize}[<4->]
      \item 這個故事說來話長，我們先舉個簡單的例子吧！
      \end{itemize}
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}
  \frametitle{舉個例子}
  \begin{exampleblock}{$1+2+3=?$}
    \begin{itemize}
    \item<2-> 答案：6。
    \item<3-> 為什麼？ (謎之音：「什麼為什麼？」)
    \end{itemize}
  \end{exampleblock}
  \begin{block}{定義}<4->
  \alert{二元運算}有一個\alert{運算子}和兩個\alert{運算元}，例如：
    \begin{enumerate}
    \item<5-> $1+2$：「$+$」稱為「運算元」，「$1$」和「$2$」稱為運算子 (我們常稱為「被加數」和「加數」)。
    \item<6-> 我們可以知道「加減乘除餘」都是二元運算。
    \end{enumerate}
  \end{block}
  \begin{itemize}[<7->]
  \item Well, 我們回到原來的問題 ...
  \end{itemize}
\end{frame}

\subsection{結合性與運算順序}

\begin{frame}[fragile]
  \frametitle{回到原來的問題 ...}
  \begin{exampleblock}{$1+2+3=?$}
    \begin{itemize}
    \item \alert{出現大麻煩啦！}
      \begin{itemize}[<2->]
        \item 根據剛剛說的，加法只有兩個運算元，那麼「$1+2+3$」該怎麼辦呢？
      \end{itemize}
    \item<3-> 解法：決定運算的\alert{方向}。例如：
      \begin{enumerate}
        \item<4-> 先算 $1+2=3$，再算 $\alert{3}+3=6$
        \item<5-> 先算 $2+3=5$，再算 $1+\alert{5}=6$
      \end{enumerate}
    \item<6-> 謎之音：「那還不是一樣嘛？廢話= =」
    \end{itemize}
  \end{exampleblock}
  \begin{alertblock}{注意}<7->
  決定運算方向對「電腦」而言\alert{意義重大}！
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{再舉個例子 ...}
  \begin{exampleblock}{$1-2-3=?$}
    \begin{itemize}
    \item<2-> 我們直觀上會先算 $1-2=-1$，再算 $\alert{-1}-3=-4$。
    \item<3-> 因此 C++ 在設計上也會把加減乘除餘的\alert{結合性}「設定」成\alert{從左到右算}。
    \end{itemize}
  \end{exampleblock}
  \pause \pause \pause
  \begin{table}[h]
    \begin{tabular}{|c|c|c|c|}
    \hline
    算術運算子      & 意義 & 運算順序 & \alert{結合性}\\
    \hline
    \lstinline{+} & 加法 & 6       & \alert{左$\rightarrow$右}\\
    \hline
    \lstinline{-} & 減法 & 6       & \alert{左$\rightarrow$右}\\
    \hline
    \lstinline{*} & 乘法 & 5       & \alert{左$\rightarrow$右}\\
    \hline
    \lstinline{/} & 除法 & 5       & \alert{左$\rightarrow$右}\\
    \hline
    \lstinline{%} & 取餘數 & 5       & \alert{左$\rightarrow$右}\\
    \hline
    \end{tabular}
    \caption{算術運算子}
  \end{table}
\end{frame}

\begin{frame}[fragile]
  \frametitle{萬一是四則運算呢？}
  \begin{exampleblock}{$1+2*3-4=?$}
    \begin{itemize}
    \item<2-> 我們的運算規則：「\alert{先乘除餘，後加減}」。
    \item<3-> 因此 C++ 發展出一套規則：\alert{運算順序}
      \begin{itemize}
      \item<4-> 運算順序小的優先運算
      \item<5-> 若運算順序相同，則依照運算方向做計算。
      \end{itemize}
    \end{itemize}
  \end{exampleblock}
  \pause \pause \pause \pause \pause
  \begin{table}[h]
    \begin{tabular}{|c|c|c|c|}
    \hline
    算術運算子      & 意義 & \alert{運算順序} & 結合性\\
    \hline
    \lstinline{+} & 加法 & \alert{6}       & 左$\rightarrow$右\\
    \hline
    \lstinline{-} & 減法 & \alert{6}       & 左$\rightarrow$右\\
    \hline
    \lstinline{*} & 乘法 & \alert{5}       & 左$\rightarrow$右\\
    \hline
    \lstinline{/} & 除法 & \alert{5}       & 左$\rightarrow$右\\
    \hline
    \lstinline{%} & 取餘數 & \alert{5}     & 左$\rightarrow$右\\
    \hline
    \end{tabular}
    \caption{算術運算子}
  \end{table}
\end{frame}

\begin{frame}
  \frametitle{回到原來例子}
  \begin{exampleblock}{$1+2*3-4=?$}
    \begin{align*}
    \onslide<1->{  & 1+\alert{2*3}-4 &\text{我們可以看到 }*\text{ 的運算順序最高}\\}
    \onslide<2->{= & \alert{1+6}-4   &\text{加法和減法運算順序相同，依照結合性從左到右算}\\}
    \onslide<3->{= & \alert{7-4}     &\text{依照結合性從左到右算}\\
                 = & 3}
    \end{align*}
  \end{exampleblock}
  \begin{alertblock}{觀念}<4->
    \begin{itemize}
    \item C++ 的四則運算用\alert{優先順序}和\alert{結合性}來處理。
    \item<5-> 這件事情非常重要，稍後就會知道為什麼。
    \end{itemize}
  \end{alertblock}
\end{frame}

\subsection{整數除法與除零問題}

\begin{frame}[fragile]
  \frametitle{整數除法}
  \begin{block}{整數除法}
    \begin{enumerate}[<+->]
    \item \lstinline{cout << 8 / 5 << endl;} 的結果？\onslide<+->{\alert{Ans: 1}}
    \item \lstinline{cout << 8.0 / 5.0 << endl;} 的結果？\onslide<+->{\alert{Ans: 1.6}}
    \end{enumerate}
  \end{block}
  \begin{exampleblock}{註}<+->
    \begin{itemize}
    \item 在 \lstinline{8 / 5} 中，8 和 5 被視為 \lstinline{int}，因此 C++ 會做「\alert{整數除法}」。
    \item<+-> 而在 \lstinline{8.0 / 5.0} 中，8.0 和 5.0 被視為浮點數 \lstinline{double}，因此會做「\alert{浮點數除法}」。
    \end{itemize}
  \end{exampleblock}
  \begin{itemize}[<+->]
  \item 除法還有另外一個問題點 ...
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{除以零}
  \begin{block}{試試看}
    我們知道數學上是不能除以零的，那程式呢？
    \begin{enumerate}
    \item \lstinline{cout << 1 / 0 << endl;}
    \item<3-> \lstinline{cout << 0 / 0 << endl;}
    \item<4-> \lstinline{cout << 1.0 / 0.0 << endl;}
    \item<5-> \lstinline{cout << 0.0 / 0.0 << endl;}
    \end{enumerate}
  \end{block}
  \begin{exampleblock}{註}<2->
  如果無法編譯成功，那麼就宣告一個變數，把分母裝進去再試試看。
  \end{exampleblock}
  \begin{alertblock}{注意}<6->
  通常編譯可以過，但是在執行時會出些狀況，各位知道出了哪些狀況就好，不用了解太詳細。
  \end{alertblock}
\end{frame}

\subsection{應用：取餘數}

\begin{frame}[fragile]
  \frametitle{取餘數}
  \begin{block}{觀察現象}
    \begin{enumerate}[<+->]
    \item \lstinline{cout << 5 % 3 << endl;} 會輸出什麼？\onslide<+->{\alert{Ans:2}}
    \item \lstinline{cout << (-5) % 3 << endl;} 呢？\onslide<+->{\alert{Ans:-2}}
    \end{enumerate}
  \end{block}
  \begin{exampleblock}{註}<+->
    \begin{itemize}
    \item 事情不該是這樣發展的啊！！！
    \item<+-> 謎之音：「應該結果是要 1 才對。」
      \begin{itemize}[<+->]
      \item C++ 一個\alert{奇怪的特性} ...
      \end{itemize}
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{解決辦法？}
  \begin{block}{問題}<+->
  要怎麼做出取餘數的效果呢？
  \end{block}
  \begin{enumerate}[<+->]
  \item 假設 n 要 mod m ...
  \item 首先，我們取 \lstinline{n % m}
    \begin{itemize}[<+->]
    \item 如果 $n\geq{0}$\onslide<+->{，會得到介於 $0$ 到 $m-1$ 的數字}
    \item 如果 $n<0$\onslide<+->{，會得到介於 $-(m-1)$ 到 $0$ 的數字}
    \end{itemize}
  \item 接著加上 m
    \begin{itemize}[<+->]
    \item 如果 $n\geq{0}$\onslide<+->{，會得到介於 $m$ 到 $2m-1$ 的數字}
    \item 如果 $n<0$\onslide<+->{，會得到介於 $-(m-1)+m=1$ 到 $m$ 的數字}
    \item 全都修成正值了！\onslide<+->{\alert{但還差最後一步 ...}}
    \end{itemize}
  \item 最後，再 mod m 一次，把所有數字修正回 $0$ 到 $m-1$ 之間。
    \begin{itemize}[<+->]
    \item 大功告成啦~ \lstinline{(n % m + m) % m}
    \end{itemize}
  \end{enumerate}
\end{frame}

\begin{frame}
  \frametitle{練習題}
  \begin{exampleblock}{\href{http://unfortunate-dog.github.io/articles/100/p10071/}{UVa 10071}}
  \label{uva:10071}
  這題只要能夠讀懂題意都不難寫。如果不知道怎樣讀取多筆測資請先參考迴圈部分 (EOF 版)。
  \end{exampleblock}
\end{frame}

\section{比較和邏輯運算子}
\begin{frame}
  \frametitle{大綱}
  \begin{multicols}{2}
    \tableofcontents[currentsection]
  \end{multicols}
\end{frame}

\subsection{簡化規則}

\begin{frame}[fragile]
  \frametitle{比較運算子}
  \begin{table}[h]
    \begin{tabular}{|c|c|c|c|}
    \hline
    比較運算子       & 意義   & 運算順序 & 結合性\\
    \hline
    \lstinline{==} & 等於   & 9       & 左$\rightarrow$右\\
    \hline
    \lstinline{!=} & 不等於 & 9       & 左$\rightarrow$右\\
    \hline
    \lstinline{>}  & 大於   & 8       & 左$\rightarrow$右\\
    \hline
    \lstinline{<}  & 小於   & 8       & 左$\rightarrow$右\\
    \hline
    \lstinline{>=} & 不小於 & 8       & 左$\rightarrow$右\\
    \hline
    \lstinline{<=} & 不大於 & 8       & 左$\rightarrow$右\\
    \hline
    \end{tabular}
    \caption{比較運算子}
  \end{table}
  \begin{alertblock}{注意}<2->
    \begin{itemize}
    \item C++ 的等於寫作「\lstinline{==}」，不要和賦值的「\lstinline{=}」搞混。
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{回傳值}
  \begin{block}{例子}<+->
    \begin{enumerate}
    \item \lstinline{cout << (3 < 5) << endl;}，會發生什麼事？
    \end{enumerate}
  \end{block}
  \begin{exampleblock}{註}<+->
    \begin{itemize}
    \item 比較運算子也是\alert{二元運算}，他會比較兩邊數字大小：
      \begin{itemize}[<+->]
      \item 如果正確，則為 \lstinline{true}
      \item 否則就是 \lstinline{false}
      \end{itemize}
    \item<+-> 這種概念我們稱為「\alert{回傳值}」
      \begin{itemize}[<+->]
      \item 比較運算子的回傳值是布林值 \lstinline{bool}
      \item \alert{\lstinline{3 < 5}} $\Rightarrow$ \lstinline{true}
      \item 因為我們要輸出 \lstinline{true}，根據 C++ 的規則，我們知道 \lstinline{true} 代表\alert{非零}，因此會印出一個非零的數字 (通常是 1)
      \end{itemize}
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{運算簡化}
  \begin{block}{例子}<+->
  判斷整數 \lstinline{n % m} 是否「不是 0」。
  \end{block}
  \begin{exampleblock}{判斷整除}<+->
    \lstinline{n % m != 0}
    \begin{itemize}[<+->]
    \item 如果 \lstinline{n % m} 的回傳值 $\neq{0}$ $\Rightarrow$ \lstinline{true}
    \item 如果是 0，則為 \lstinline{false}
    \end{itemize}
  \end{exampleblock}
  \begin{alertblock}{簡化寫法}<+->
    \lstinline{n % m}
    \begin{itemize}[<+->]
    \item 如果 \lstinline{n % m} 的回傳值 $\neq{0}$ ，可以被當做「\lstinline{true}」
    \item 如果是 0，那麼就可以當做「\lstinline{false}」
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}
  \frametitle{遙遠的記憶}
  \begin{alertblock}{布林值的重要觀念}<+->
    \begin{itemize}
    \item C++ 中，「\alert{非零整數}」會被當做「\lstinline{true}」，印出時也會印出一個非零整數 (\alert{通常是 1})。
    \item 「0」會被當做「\lstinline{false}」，印出時會印出「\alert{0}」。
    \end{itemize}
  \end{alertblock}
  \begin{exampleblock}{註}<+->
    \begin{itemize}
    \item 簡化的寫法大多時候可以取代原來一般寫法。
    \item<+-> 通常比較運算子要和 \lstinline{if}、\lstinline{else} 配合。
    \end{itemize}
  \end{exampleblock}
\end{frame}

\subsection{短路運算}

\begin{frame}[fragile]
  \frametitle{邏輯運算子}
  \begin{table}[h]
    \begin{tabular}{|c|c|c|c|}
    \hline
    比較運算子       & 意義 & 運算順序 & 結合性\\
    \hline
    \lstinline{&&} & 且   & 13      & 左$\rightarrow$右\\
    \hline
    \lstinline{||} & 或   & 14      & 左$\rightarrow$右\\
    \hline
    \lstinline{!}  & 非   & 3       & \alert{右$\rightarrow$左}\\
    \hline
    \end{tabular}
    \caption{邏輯運算子}
  \end{table}
  \begin{exampleblock}{作用}<2->
    \begin{itemize}
    \item 一般來說是連接比較運算子
    \item<3-> 例如：\lstinline{1 < x && x < 5}
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}
  \frametitle{舉個例子}
  \begin{block}{例子}<+->
  判斷 x 是否介於 a 和 b 之間能不能寫成 \lstinline{a<=x<=b} 呢？\onslide<+->{\alert{Ans:不行}。}
  \end{block}
  \begin{exampleblock}{用回傳值的觀點}<+->
    \begin{itemize}
    \item 我們知道 \lstinline{<=} 運算子在列出很多個時，會\alert{由左到右算}
    \item \lstinline{a <= x <= b}
    \end{itemize}
  \end{exampleblock}
\end{frame}

\section{位元運算子}
\begin{frame}
  \frametitle{大綱}
  \begin{multicols}{2}
    \tableofcontents[currentsection]
  \end{multicols}
\end{frame}

\subsection{int 和 long long 的儲存形式}

\begin{frame}[fragile]
  \frametitle{int 表示法}
\end{frame}

\subsection{取特定餘數}

\subsection{mask}

\subsection{set bit}

\subsection{消失的數}

\subsection{parity}

\section{指定運算子}

\subsection{未定義行為}

\section{結論}

\begin{frame}[fragile]
  \frametitle{小結}
  \begin{alertblock}{重點整理}
    \begin{enumerate}[<+->]
    \item 句子結尾是分號「\lstinline{;}」。
    \item 初始化的重要性。
    \item C++ 依照運算順序和結合性做運算。
    \item 除以零會遇到的現象。
    \item 「零」代表 \lstinline{false}，「非零」代表 \lstinline{true}。
    \item 邏輯運算子是短路運算。
    \item \lstinline{int} 和 \lstinline{long long} 如何儲存，以及位元運算技巧。
    \item 注意未定義行為。
    \end{enumerate}
  \end{alertblock}
\end{frame}

\clearpage
\end{CJK}
\end{document}